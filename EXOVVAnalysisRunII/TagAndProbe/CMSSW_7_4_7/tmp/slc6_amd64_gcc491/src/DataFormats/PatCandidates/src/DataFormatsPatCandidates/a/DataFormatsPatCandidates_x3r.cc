// Do NOT change. Changes will be lost next time file is generated

#define R__DICTIONARY_FILENAME tmpdIslc6_amd64_gcc491dIsrcdIDataFormatsdIPatCandidatesdIsrcdIDataFormatsPatCandidatesdIadIDataFormatsPatCandidates_x3r

/*******************************************************************/
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#define G__DICTIONARY
#include "RConfig.h"
#include "TClass.h"
#include "TDictAttributeMap.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"
#include <algorithm>
#include "TCollectionProxyInfo.h"
/*******************************************************************/

#include "TDataMember.h"

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"

#include <DataFormats/PatCandidates/interface/ioread_packedgen.h>

// Header files passed as explicit arguments
#include "src/DataFormats/PatCandidates/src/classes_objects.h"

// Header files passed via #pragma extra_include

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLGsfElectrongR_Dictionary();
   static void patcLcLPATObjectlErecocLcLGsfElectrongR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLGsfElectrongR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::GsfElectron>*)
   {
      ::pat::PATObject<reco::GsfElectron> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::GsfElectron>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::GsfElectron>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::GsfElectron>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLGsfElectrongR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::GsfElectron>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLGsfElectrongR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLGsfElectrongR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLGsfElectrongR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLGsfElectrongR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLGsfElectrongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::GsfElectron>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::GsfElectron>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::GsfElectron>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLGsfElectrongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::GsfElectron>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLGsfElectrongR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLGsfElectrongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLMuongR_Dictionary();
   static void patcLcLPATObjectlErecocLcLMuongR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLMuongR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLMuongR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLMuongR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLMuongR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLMuongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::Muon>*)
   {
      ::pat::PATObject<reco::Muon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::Muon>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::Muon>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::Muon>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLMuongR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::Muon>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLMuongR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLMuongR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLMuongR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLMuongR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLMuongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::Muon>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::Muon>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::Muon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLMuongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::Muon>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLMuongR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLMuongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLBaseTaugR_Dictionary();
   static void patcLcLPATObjectlErecocLcLBaseTaugR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLBaseTaugR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLBaseTaugR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLBaseTaugR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLBaseTaugR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLBaseTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::BaseTau>*)
   {
      ::pat::PATObject<reco::BaseTau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::BaseTau>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::BaseTau>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::BaseTau>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLBaseTaugR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::BaseTau>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLBaseTaugR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLBaseTaugR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLBaseTaugR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLBaseTaugR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLBaseTaugR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::BaseTau>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::BaseTau>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::BaseTau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLBaseTaugR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::BaseTau>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLBaseTaugR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLBaseTaugR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLPhotongR_Dictionary();
   static void patcLcLPATObjectlErecocLcLPhotongR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLPhotongR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLPhotongR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLPhotongR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLPhotongR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLPhotongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::Photon>*)
   {
      ::pat::PATObject<reco::Photon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::Photon>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::Photon>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::Photon>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLPhotongR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::Photon>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLPhotongR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLPhotongR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLPhotongR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLPhotongR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLPhotongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::Photon>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::Photon>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::Photon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLPhotongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::Photon>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLPhotongR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLPhotongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLJetgR_Dictionary();
   static void patcLcLPATObjectlErecocLcLJetgR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLJetgR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLJetgR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLJetgR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLJetgR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLJetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::Jet>*)
   {
      ::pat::PATObject<reco::Jet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::Jet>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::Jet>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::Jet>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLJetgR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::Jet>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLJetgR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLJetgR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLJetgR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLJetgR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLJetgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::Jet>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::Jet>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::Jet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLJetgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::Jet>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLJetgR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLJetgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLMETgR_Dictionary();
   static void patcLcLPATObjectlErecocLcLMETgR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLMETgR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLMETgR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLMETgR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLMETgR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLMETgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::MET>*)
   {
      ::pat::PATObject<reco::MET> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::MET>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::MET>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::MET>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLMETgR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::MET>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLMETgR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLMETgR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLMETgR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLMETgR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLMETgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::MET>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::MET>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::MET>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLMETgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::MET>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLMETgR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLMETgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLLeafCandidategR_Dictionary();
   static void patcLcLPATObjectlErecocLcLLeafCandidategR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLLeafCandidategR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::LeafCandidate>*)
   {
      ::pat::PATObject<reco::LeafCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::LeafCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::LeafCandidate>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::LeafCandidate>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLLeafCandidategR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::LeafCandidate>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLLeafCandidategR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLLeafCandidategR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLLeafCandidategR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLLeafCandidategR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLLeafCandidategR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::LeafCandidate>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::LeafCandidate>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::LeafCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLLeafCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::LeafCandidate>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLLeafCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLLeafCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLCompositeCandidategR_Dictionary();
   static void patcLcLPATObjectlErecocLcLCompositeCandidategR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLCompositeCandidategR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::CompositeCandidate>*)
   {
      ::pat::PATObject<reco::CompositeCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::CompositeCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::CompositeCandidate>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::CompositeCandidate>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLCompositeCandidategR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::CompositeCandidate>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLCompositeCandidategR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLCompositeCandidategR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLCompositeCandidategR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLCompositeCandidategR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLCompositeCandidategR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::CompositeCandidate>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::CompositeCandidate>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::CompositeCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLCompositeCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::CompositeCandidate>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLCompositeCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLCompositeCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLPFCandidategR_Dictionary();
   static void patcLcLPATObjectlErecocLcLPFCandidategR_TClassManip(TClass*);
   static void *new_patcLcLPATObjectlErecocLcLPFCandidategR(void *p = 0);
   static void *newArray_patcLcLPATObjectlErecocLcLPFCandidategR(Long_t size, void *p);
   static void delete_patcLcLPATObjectlErecocLcLPFCandidategR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLPFCandidategR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLPFCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::PFCandidate>*)
   {
      ::pat::PATObject<reco::PFCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::PFCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::PFCandidate>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::PFCandidate>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLPFCandidategR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::PFCandidate>) );
      instance.SetNew(&new_patcLcLPATObjectlErecocLcLPFCandidategR);
      instance.SetNewArray(&newArray_patcLcLPATObjectlErecocLcLPFCandidategR);
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLPFCandidategR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLPFCandidategR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLPFCandidategR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::PFCandidate>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::PFCandidate>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::PFCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLPFCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::PFCandidate>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLPFCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLPFCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPATObjectlErecocLcLRecoCandidategR_Dictionary();
   static void patcLcLPATObjectlErecocLcLRecoCandidategR_TClassManip(TClass*);
   static void delete_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p);
   static void deleteArray_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p);
   static void destruct_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PATObject<reco::RecoCandidate>*)
   {
      ::pat::PATObject<reco::RecoCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PATObject<reco::RecoCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PATObject<reco::RecoCandidate>", "DataFormats/PatCandidates/interface/PATObject.h", 41,
                  typeid(::pat::PATObject<reco::RecoCandidate>), DefineBehavior(ptr, ptr),
                  &patcLcLPATObjectlErecocLcLRecoCandidategR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::PATObject<reco::RecoCandidate>) );
      instance.SetDelete(&delete_patcLcLPATObjectlErecocLcLRecoCandidategR);
      instance.SetDeleteArray(&deleteArray_patcLcLPATObjectlErecocLcLRecoCandidategR);
      instance.SetDestructor(&destruct_patcLcLPATObjectlErecocLcLRecoCandidategR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PATObject<reco::RecoCandidate>*)
   {
      return GenerateInitInstanceLocal((::pat::PATObject<reco::RecoCandidate>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PATObject<reco::RecoCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPATObjectlErecocLcLRecoCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PATObject<reco::RecoCandidate>*)0x0)->GetClass();
      patcLcLPATObjectlErecocLcLRecoCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPATObjectlErecocLcLRecoCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLLeptonlErecocLcLGsfElectrongR_Dictionary();
   static void patcLcLLeptonlErecocLcLGsfElectrongR_TClassManip(TClass*);
   static void *new_patcLcLLeptonlErecocLcLGsfElectrongR(void *p = 0);
   static void *newArray_patcLcLLeptonlErecocLcLGsfElectrongR(Long_t size, void *p);
   static void delete_patcLcLLeptonlErecocLcLGsfElectrongR(void *p);
   static void deleteArray_patcLcLLeptonlErecocLcLGsfElectrongR(void *p);
   static void destruct_patcLcLLeptonlErecocLcLGsfElectrongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Lepton<reco::GsfElectron>*)
   {
      ::pat::Lepton<reco::GsfElectron> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Lepton<reco::GsfElectron>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Lepton<reco::GsfElectron>", "DataFormats/PatCandidates/interface/Lepton.h", 30,
                  typeid(::pat::Lepton<reco::GsfElectron>), DefineBehavior(ptr, ptr),
                  &patcLcLLeptonlErecocLcLGsfElectrongR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::Lepton<reco::GsfElectron>) );
      instance.SetNew(&new_patcLcLLeptonlErecocLcLGsfElectrongR);
      instance.SetNewArray(&newArray_patcLcLLeptonlErecocLcLGsfElectrongR);
      instance.SetDelete(&delete_patcLcLLeptonlErecocLcLGsfElectrongR);
      instance.SetDeleteArray(&deleteArray_patcLcLLeptonlErecocLcLGsfElectrongR);
      instance.SetDestructor(&destruct_patcLcLLeptonlErecocLcLGsfElectrongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Lepton<reco::GsfElectron>*)
   {
      return GenerateInitInstanceLocal((::pat::Lepton<reco::GsfElectron>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Lepton<reco::GsfElectron>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLLeptonlErecocLcLGsfElectrongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Lepton<reco::GsfElectron>*)0x0)->GetClass();
      patcLcLLeptonlErecocLcLGsfElectrongR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLLeptonlErecocLcLGsfElectrongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLLeptonlErecocLcLMuongR_Dictionary();
   static void patcLcLLeptonlErecocLcLMuongR_TClassManip(TClass*);
   static void *new_patcLcLLeptonlErecocLcLMuongR(void *p = 0);
   static void *newArray_patcLcLLeptonlErecocLcLMuongR(Long_t size, void *p);
   static void delete_patcLcLLeptonlErecocLcLMuongR(void *p);
   static void deleteArray_patcLcLLeptonlErecocLcLMuongR(void *p);
   static void destruct_patcLcLLeptonlErecocLcLMuongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Lepton<reco::Muon>*)
   {
      ::pat::Lepton<reco::Muon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Lepton<reco::Muon>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Lepton<reco::Muon>", "DataFormats/PatCandidates/interface/Lepton.h", 30,
                  typeid(::pat::Lepton<reco::Muon>), DefineBehavior(ptr, ptr),
                  &patcLcLLeptonlErecocLcLMuongR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::Lepton<reco::Muon>) );
      instance.SetNew(&new_patcLcLLeptonlErecocLcLMuongR);
      instance.SetNewArray(&newArray_patcLcLLeptonlErecocLcLMuongR);
      instance.SetDelete(&delete_patcLcLLeptonlErecocLcLMuongR);
      instance.SetDeleteArray(&deleteArray_patcLcLLeptonlErecocLcLMuongR);
      instance.SetDestructor(&destruct_patcLcLLeptonlErecocLcLMuongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Lepton<reco::Muon>*)
   {
      return GenerateInitInstanceLocal((::pat::Lepton<reco::Muon>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Lepton<reco::Muon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLLeptonlErecocLcLMuongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Lepton<reco::Muon>*)0x0)->GetClass();
      patcLcLLeptonlErecocLcLMuongR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLLeptonlErecocLcLMuongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLLeptonlErecocLcLBaseTaugR_Dictionary();
   static void patcLcLLeptonlErecocLcLBaseTaugR_TClassManip(TClass*);
   static void *new_patcLcLLeptonlErecocLcLBaseTaugR(void *p = 0);
   static void *newArray_patcLcLLeptonlErecocLcLBaseTaugR(Long_t size, void *p);
   static void delete_patcLcLLeptonlErecocLcLBaseTaugR(void *p);
   static void deleteArray_patcLcLLeptonlErecocLcLBaseTaugR(void *p);
   static void destruct_patcLcLLeptonlErecocLcLBaseTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Lepton<reco::BaseTau>*)
   {
      ::pat::Lepton<reco::BaseTau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Lepton<reco::BaseTau>));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Lepton<reco::BaseTau>", "DataFormats/PatCandidates/interface/Lepton.h", 30,
                  typeid(::pat::Lepton<reco::BaseTau>), DefineBehavior(ptr, ptr),
                  &patcLcLLeptonlErecocLcLBaseTaugR_Dictionary, isa_proxy, 0,
                  sizeof(::pat::Lepton<reco::BaseTau>) );
      instance.SetNew(&new_patcLcLLeptonlErecocLcLBaseTaugR);
      instance.SetNewArray(&newArray_patcLcLLeptonlErecocLcLBaseTaugR);
      instance.SetDelete(&delete_patcLcLLeptonlErecocLcLBaseTaugR);
      instance.SetDeleteArray(&deleteArray_patcLcLLeptonlErecocLcLBaseTaugR);
      instance.SetDestructor(&destruct_patcLcLLeptonlErecocLcLBaseTaugR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Lepton<reco::BaseTau>*)
   {
      return GenerateInitInstanceLocal((::pat::Lepton<reco::BaseTau>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Lepton<reco::BaseTau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLLeptonlErecocLcLBaseTaugR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Lepton<reco::BaseTau>*)0x0)->GetClass();
      patcLcLLeptonlErecocLcLBaseTaugR_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLLeptonlErecocLcLBaseTaugR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLElectron_Dictionary();
   static void patcLcLElectron_TClassManip(TClass*);
   static void *new_patcLcLElectron(void *p = 0);
   static void *newArray_patcLcLElectron(Long_t size, void *p);
   static void delete_patcLcLElectron(void *p);
   static void deleteArray_patcLcLElectron(void *p);
   static void destruct_patcLcLElectron(void *p);

   // Schema evolution read functions
   static void read_patcLcLElectron_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Electron");
      static Long_t offset_superClusterRelinked_ = cls->GetDataMemberOffset("superClusterRelinked_");
      edm::AtomicPtrCache<vector<reco::SuperCluster> >& superClusterRelinked_ = *(edm::AtomicPtrCache<vector<reco::SuperCluster> >*)(target+offset_superClusterRelinked_);
      pat::Electron* newObj = (pat::Electron*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     superClusterRelinked_.reset();
   }
   static void read_patcLcLElectron_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_ip_ = oldObj->GetId("ip_");
#endif
      struct patcLcLElectron_Onfile {
         std::vector<double> &ip_;
         patcLcLElectron_Onfile(std::vector<double> &onfile_ip_ ): ip_(onfile_ip_) {}
      };
      static Long_t offset_Onfile_patcLcLElectron_ip_ = oldObj->GetClass()->GetDataMemberOffset("ip_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLElectron_Onfile onfile(
         *(std::vector<double>*)(onfile_add+offset_Onfile_patcLcLElectron_ip_) );

      static TClassRef cls("pat::Electron");
      static Long_t offset_ip_ = cls->GetDataMemberOffset("ip_");
      typedef float ip__t[4];
      ip__t& ip_ = *(ip__t *)(target+offset_ip_);
      pat::Electron* newObj = (pat::Electron*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      ip_[0] = onfile.ip_[1]; ip_[1] = onfile.ip_[2]; ip_[2] = onfile.ip_[3]; ip_[3] = onfile.ip_[4]; 
   }
   static void read_patcLcLElectron_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_eip_ = oldObj->GetId("eip_");
#endif
      struct patcLcLElectron_Onfile {
         std::vector<double> &eip_;
         patcLcLElectron_Onfile(std::vector<double> &onfile_eip_ ): eip_(onfile_eip_) {}
      };
      static Long_t offset_Onfile_patcLcLElectron_eip_ = oldObj->GetClass()->GetDataMemberOffset("eip_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLElectron_Onfile onfile(
         *(std::vector<double>*)(onfile_add+offset_Onfile_patcLcLElectron_eip_) );

      static TClassRef cls("pat::Electron");
      static Long_t offset_eip_ = cls->GetDataMemberOffset("eip_");
      typedef float eip__t[4];
      eip__t& eip_ = *(eip__t *)(target+offset_eip_);
      pat::Electron* newObj = (pat::Electron*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      eip_[0] = onfile.eip_[1]; eip_[1] = onfile.eip_[2]; eip_[2] = onfile.eip_[3]; eip_[3] = onfile.eip_[4]; 
   }
   static void read_patcLcLElectron_3( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_cachedIP_ = oldObj->GetId("cachedIP_");
#endif
      struct patcLcLElectron_Onfile {
         std::vector<bool> &cachedIP_;
         patcLcLElectron_Onfile(std::vector<bool> &onfile_cachedIP_ ): cachedIP_(onfile_cachedIP_) {}
      };
      static Long_t offset_Onfile_patcLcLElectron_cachedIP_ = oldObj->GetClass()->GetDataMemberOffset("cachedIP_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLElectron_Onfile onfile(
         *(std::vector<bool>*)(onfile_add+offset_Onfile_patcLcLElectron_cachedIP_) );

      static TClassRef cls("pat::Electron");
      static Long_t offset_cachedIP_ = cls->GetDataMemberOffset("cachedIP_");
      uint8_t& cachedIP_ = *(uint8_t*)(target+offset_cachedIP_);
      pat::Electron* newObj = (pat::Electron*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      cachedIP_ = onfile.cachedIP_[1] + 2*onfile.cachedIP_[2] + 4*onfile.cachedIP_[3] + 8*onfile.cachedIP_[4]; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Electron*)
   {
      ::pat::Electron *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Electron));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Electron", 33, "DataFormats/PatCandidates/interface/Electron.h", 52,
                  typeid(::pat::Electron), DefineBehavior(ptr, ptr),
                  &patcLcLElectron_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Electron) );
      instance.SetNew(&new_patcLcLElectron);
      instance.SetNewArray(&newArray_patcLcLElectron);
      instance.SetDelete(&delete_patcLcLElectron);
      instance.SetDeleteArray(&deleteArray_patcLcLElectron);
      instance.SetDestructor(&destruct_patcLcLElectron);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(4);
      rule = &readrules[0];
      rule->fSourceClass = "pat::Electron";
      rule->fTarget      = "superClusterRelinked_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLElectron_0);
      rule->fCode        = "superClusterRelinked_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[1];
      rule->fSourceClass = "pat::Electron";
      rule->fTarget      = "ip_";
      rule->fSource      = "std::vector<double> ip_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLElectron_1);
      rule->fCode        = " ip_[0] = onfile.ip_[1]; ip_[1] = onfile.ip_[2]; ip_[2] = onfile.ip_[3]; ip_[3] = onfile.ip_[4]; ";
      rule->fVersion     = "[-28]";
      rule->fEmbed       = false;
      rule = &readrules[2];
      rule->fSourceClass = "pat::Electron";
      rule->fTarget      = "eip_";
      rule->fSource      = "std::vector<double> eip_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLElectron_2);
      rule->fCode        = " eip_[0] = onfile.eip_[1]; eip_[1] = onfile.eip_[2]; eip_[2] = onfile.eip_[3]; eip_[3] = onfile.eip_[4]; ";
      rule->fVersion     = "[-28]";
      rule->fEmbed       = false;
      rule = &readrules[3];
      rule->fSourceClass = "pat::Electron";
      rule->fTarget      = "cachedIP_";
      rule->fSource      = "std::vector<bool> cachedIP_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLElectron_3);
      rule->fCode        = " cachedIP_ = onfile.cachedIP_[1] + 2*onfile.cachedIP_[2] + 4*onfile.cachedIP_[3] + 8*onfile.cachedIP_[4]; ";
      rule->fVersion     = "[-28]";
      rule->fEmbed       = false;
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Electron*)
   {
      return GenerateInitInstanceLocal((::pat::Electron*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Electron*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLElectron_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Electron*)0x0)->GetClass();
      patcLcLElectron_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLElectron_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_Dictionary();
   static void edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p = 0);
   static void *newArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(Long_t size, void *p);
   static void delete_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p);
   static void deleteArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p);
   static void destruct_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)
   {
      ::edm::AtomicPtrCache<vector<reco::SuperCluster> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::AtomicPtrCache<vector<reco::SuperCluster> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::AtomicPtrCache<vector<reco::SuperCluster> >", "DataFormats/Common/interface/AtomicPtrCache.h", 40,
                  typeid(::edm::AtomicPtrCache<vector<reco::SuperCluster> >), DefineBehavior(ptr, ptr),
                  &edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::AtomicPtrCache<vector<reco::SuperCluster> >) );
      instance.SetNew(&new_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR);
      instance.SetNewArray(&newArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR);
      instance.SetDelete(&delete_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR);
      instance.SetDestructor(&destruct_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR);

      ROOT::AddClassAlternate("edm::AtomicPtrCache<vector<reco::SuperCluster> >","edm::AtomicPtrCache<std::vector<reco::SuperCluster> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)
   {
      return GenerateInitInstanceLocal((::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)0x0)->GetClass();
      edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLMuon_Dictionary();
   static void patcLcLMuon_TClassManip(TClass*);
   static void *new_patcLcLMuon(void *p = 0);
   static void *newArray_patcLcLMuon(Long_t size, void *p);
   static void delete_patcLcLMuon(void *p);
   static void deleteArray_patcLcLMuon(void *p);
   static void destruct_patcLcLMuon(void *p);

   // Schema evolution read functions
   static void read_patcLcLMuon_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_ip_ = oldObj->GetId("ip_");
#endif
      struct patcLcLMuon_Onfile {
         std::vector<double> &ip_;
         patcLcLMuon_Onfile(std::vector<double> &onfile_ip_ ): ip_(onfile_ip_) {}
      };
      static Long_t offset_Onfile_patcLcLMuon_ip_ = oldObj->GetClass()->GetDataMemberOffset("ip_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLMuon_Onfile onfile(
         *(std::vector<double>*)(onfile_add+offset_Onfile_patcLcLMuon_ip_) );

      static TClassRef cls("pat::Muon");
      static Long_t offset_ip_ = cls->GetDataMemberOffset("ip_");
      typedef float ip__t[4];
      ip__t& ip_ = *(ip__t *)(target+offset_ip_);
      pat::Muon* newObj = (pat::Muon*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      ip_[0] = onfile.ip_[1]; ip_[1] = onfile.ip_[2]; ip_[2] = onfile.ip_[3]; ip_[3] = onfile.ip_[4]; 
   }
   static void read_patcLcLMuon_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_eip_ = oldObj->GetId("eip_");
#endif
      struct patcLcLMuon_Onfile {
         std::vector<double> &eip_;
         patcLcLMuon_Onfile(std::vector<double> &onfile_eip_ ): eip_(onfile_eip_) {}
      };
      static Long_t offset_Onfile_patcLcLMuon_eip_ = oldObj->GetClass()->GetDataMemberOffset("eip_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLMuon_Onfile onfile(
         *(std::vector<double>*)(onfile_add+offset_Onfile_patcLcLMuon_eip_) );

      static TClassRef cls("pat::Muon");
      static Long_t offset_eip_ = cls->GetDataMemberOffset("eip_");
      typedef float eip__t[4];
      eip__t& eip_ = *(eip__t *)(target+offset_eip_);
      pat::Muon* newObj = (pat::Muon*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      eip_[0] = onfile.eip_[1]; eip_[1] = onfile.eip_[2]; eip_[2] = onfile.eip_[3]; eip_[3] = onfile.eip_[4]; 
   }
   static void read_patcLcLMuon_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_cachedIP_ = oldObj->GetId("cachedIP_");
#endif
      struct patcLcLMuon_Onfile {
         std::vector<bool> &cachedIP_;
         patcLcLMuon_Onfile(std::vector<bool> &onfile_cachedIP_ ): cachedIP_(onfile_cachedIP_) {}
      };
      static Long_t offset_Onfile_patcLcLMuon_cachedIP_ = oldObj->GetClass()->GetDataMemberOffset("cachedIP_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLMuon_Onfile onfile(
         *(std::vector<bool>*)(onfile_add+offset_Onfile_patcLcLMuon_cachedIP_) );

      static TClassRef cls("pat::Muon");
      static Long_t offset_cachedIP_ = cls->GetDataMemberOffset("cachedIP_");
      uint8_t& cachedIP_ = *(uint8_t*)(target+offset_cachedIP_);
      pat::Muon* newObj = (pat::Muon*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      cachedIP_ = onfile.cachedIP_[1] + 2*onfile.cachedIP_[2] + 4*onfile.cachedIP_[3] + 8*onfile.cachedIP_[4]; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Muon*)
   {
      ::pat::Muon *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Muon));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Muon", 18, "DataFormats/PatCandidates/interface/Muon.h", 49,
                  typeid(::pat::Muon), DefineBehavior(ptr, ptr),
                  &patcLcLMuon_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Muon) );
      instance.SetNew(&new_patcLcLMuon);
      instance.SetNewArray(&newArray_patcLcLMuon);
      instance.SetDelete(&delete_patcLcLMuon);
      instance.SetDeleteArray(&deleteArray_patcLcLMuon);
      instance.SetDestructor(&destruct_patcLcLMuon);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(3);
      rule = &readrules[0];
      rule->fSourceClass = "pat::Muon";
      rule->fTarget      = "ip_";
      rule->fSource      = "std::vector<double> ip_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLMuon_0);
      rule->fCode        = " ip_[0] = onfile.ip_[1]; ip_[1] = onfile.ip_[2]; ip_[2] = onfile.ip_[3]; ip_[3] = onfile.ip_[4]; ";
      rule->fVersion     = "[-16]";
      rule->fEmbed       = false;
      rule = &readrules[1];
      rule->fSourceClass = "pat::Muon";
      rule->fTarget      = "eip_";
      rule->fSource      = "std::vector<double> eip_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLMuon_1);
      rule->fCode        = " eip_[0] = onfile.eip_[1]; eip_[1] = onfile.eip_[2]; eip_[2] = onfile.eip_[3]; eip_[3] = onfile.eip_[4]; ";
      rule->fVersion     = "[-16]";
      rule->fEmbed       = false;
      rule = &readrules[2];
      rule->fSourceClass = "pat::Muon";
      rule->fTarget      = "cachedIP_";
      rule->fSource      = "std::vector<bool> cachedIP_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLMuon_2);
      rule->fCode        = " cachedIP_ = onfile.cachedIP_[1] + 2*onfile.cachedIP_[2] + 4*onfile.cachedIP_[3] + 8*onfile.cachedIP_[4]; ";
      rule->fVersion     = "[-16]";
      rule->fEmbed       = false;
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Muon*)
   {
      return GenerateInitInstanceLocal((::pat::Muon*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Muon*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLMuon_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Muon*)0x0)->GetClass();
      patcLcLMuon_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLMuon_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLTau_Dictionary();
   static void patcLcLTau_TClassManip(TClass*);
   static void *new_patcLcLTau(void *p = 0);
   static void *newArray_patcLcLTau(Long_t size, void *p);
   static void delete_patcLcLTau(void *p);
   static void deleteArray_patcLcLTau(void *p);
   static void destruct_patcLcLTau(void *p);

   // Schema evolution read functions
   static void read_patcLcLTau_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_isolationTracksTransientRefVector_ = cls->GetDataMemberOffset("isolationTracksTransientRefVector_");
      edm::AtomicPtrCache<reco::TrackRefVector>& isolationTracksTransientRefVector_ = *(edm::AtomicPtrCache<reco::TrackRefVector>*)(target+offset_isolationTracksTransientRefVector_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     isolationTracksTransientRefVector_.reset();
   }
   static void read_patcLcLTau_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_signalTracksTransientRefVector_ = cls->GetDataMemberOffset("signalTracksTransientRefVector_");
      edm::AtomicPtrCache<reco::TrackRefVector>& signalTracksTransientRefVector_ = *(edm::AtomicPtrCache<reco::TrackRefVector>*)(target+offset_signalTracksTransientRefVector_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     signalTracksTransientRefVector_.reset();
   }
   static void read_patcLcLTau_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_signalPFCandsTransientPtrs_ = cls->GetDataMemberOffset("signalPFCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& signalPFCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_signalPFCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     signalPFCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_3( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_signalPFChargedHadrCandsTransientPtrs_ = cls->GetDataMemberOffset("signalPFChargedHadrCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& signalPFChargedHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_signalPFChargedHadrCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     signalPFChargedHadrCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_4( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_signalPFNeutralHadrCandsTransientPtrs_ = cls->GetDataMemberOffset("signalPFNeutralHadrCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& signalPFNeutralHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_signalPFNeutralHadrCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     signalPFNeutralHadrCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_5( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_signalPFGammaCandsTransientPtrs_ = cls->GetDataMemberOffset("signalPFGammaCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& signalPFGammaCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_signalPFGammaCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     signalPFGammaCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_6( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_isolationPFCandsTransientPtrs_ = cls->GetDataMemberOffset("isolationPFCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& isolationPFCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_isolationPFCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     isolationPFCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_7( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_isolationPFChargedHadrCandsTransientPtrs_ = cls->GetDataMemberOffset("isolationPFChargedHadrCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& isolationPFChargedHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_isolationPFChargedHadrCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     isolationPFChargedHadrCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_8( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_isolationPFNeutralHadrCandsTransientPtrs_ = cls->GetDataMemberOffset("isolationPFNeutralHadrCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& isolationPFNeutralHadrCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_isolationPFNeutralHadrCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     isolationPFNeutralHadrCandsTransientPtrs_.reset();
   }
   static void read_patcLcLTau_9( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Tau");
      static Long_t offset_isolationPFGammaCandsTransientPtrs_ = cls->GetDataMemberOffset("isolationPFGammaCandsTransientPtrs_");
      edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >& isolationPFGammaCandsTransientPtrs_ = *(edm::AtomicPtrCache<vector<reco::PFCandidatePtr> >*)(target+offset_isolationPFGammaCandsTransientPtrs_);
      pat::Tau* newObj = (pat::Tau*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     isolationPFGammaCandsTransientPtrs_.reset();
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Tau*)
   {
      ::pat::Tau *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Tau));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Tau", 17, "DataFormats/PatCandidates/interface/Tau.h", 56,
                  typeid(::pat::Tau), DefineBehavior(ptr, ptr),
                  &patcLcLTau_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Tau) );
      instance.SetNew(&new_patcLcLTau);
      instance.SetNewArray(&newArray_patcLcLTau);
      instance.SetDelete(&delete_patcLcLTau);
      instance.SetDeleteArray(&deleteArray_patcLcLTau);
      instance.SetDestructor(&destruct_patcLcLTau);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(10);
      rule = &readrules[0];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "isolationTracksTransientRefVector_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_0);
      rule->fCode        = "isolationTracksTransientRefVector_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[1];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "signalTracksTransientRefVector_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_1);
      rule->fCode        = "signalTracksTransientRefVector_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[2];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "signalPFCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_2);
      rule->fCode        = "signalPFCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[3];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "signalPFChargedHadrCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_3);
      rule->fCode        = "signalPFChargedHadrCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[4];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "signalPFNeutralHadrCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_4);
      rule->fCode        = "signalPFNeutralHadrCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[5];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "signalPFGammaCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_5);
      rule->fCode        = "signalPFGammaCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[6];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "isolationPFCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_6);
      rule->fCode        = "isolationPFCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[7];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "isolationPFChargedHadrCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_7);
      rule->fCode        = "isolationPFChargedHadrCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[8];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "isolationPFNeutralHadrCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_8);
      rule->fCode        = "isolationPFNeutralHadrCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      rule = &readrules[9];
      rule->fSourceClass = "pat::Tau";
      rule->fTarget      = "isolationPFGammaCandsTransientPtrs_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLTau_9);
      rule->fCode        = "isolationPFGammaCandsTransientPtrs_.reset();";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Tau*)
   {
      return GenerateInitInstanceLocal((::pat::Tau*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Tau*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLTau_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Tau*)0x0)->GetClass();
      patcLcLTau_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLTau_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_Dictionary();
   static void edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p);
   static void destruct_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)
   {
      ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >", "DataFormats/Common/interface/AtomicPtrCache.h", 40,
                  typeid(::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >) );
      instance.SetNew(&new_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >","edm::AtomicPtrCache<reco::TrackRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)
   {
      return GenerateInitInstanceLocal((::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)0x0)->GetClass();
      edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)
   {
      ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >", "DataFormats/Common/interface/AtomicPtrCache.h", 40,
                  typeid(::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >) );
      instance.SetNew(&new_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >","edm::AtomicPtrCache<std::vector<reco::PFCandidatePtr> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)0x0)->GetClass();
      edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLtaucLcLTauPFSpecific_Dictionary();
   static void patcLcLtaucLcLTauPFSpecific_TClassManip(TClass*);
   static void *new_patcLcLtaucLcLTauPFSpecific(void *p = 0);
   static void *newArray_patcLcLtaucLcLTauPFSpecific(Long_t size, void *p);
   static void delete_patcLcLtaucLcLTauPFSpecific(void *p);
   static void deleteArray_patcLcLtaucLcLTauPFSpecific(void *p);
   static void destruct_patcLcLtaucLcLTauPFSpecific(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::tau::TauPFSpecific*)
   {
      ::pat::tau::TauPFSpecific *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::tau::TauPFSpecific));
      static ::ROOT::TGenericClassInfo 
         instance("pat::tau::TauPFSpecific", 14, "DataFormats/PatCandidates/interface/TauPFSpecific.h", 21,
                  typeid(::pat::tau::TauPFSpecific), DefineBehavior(ptr, ptr),
                  &patcLcLtaucLcLTauPFSpecific_Dictionary, isa_proxy, 8,
                  sizeof(::pat::tau::TauPFSpecific) );
      instance.SetNew(&new_patcLcLtaucLcLTauPFSpecific);
      instance.SetNewArray(&newArray_patcLcLtaucLcLTauPFSpecific);
      instance.SetDelete(&delete_patcLcLtaucLcLTauPFSpecific);
      instance.SetDeleteArray(&deleteArray_patcLcLtaucLcLTauPFSpecific);
      instance.SetDestructor(&destruct_patcLcLtaucLcLTauPFSpecific);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::tau::TauPFSpecific*)
   {
      return GenerateInitInstanceLocal((::pat::tau::TauPFSpecific*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::tau::TauPFSpecific*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLtaucLcLTauPFSpecific_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::tau::TauPFSpecific*)0x0)->GetClass();
      patcLcLtaucLcLTauPFSpecific_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLtaucLcLTauPFSpecific_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLtaucLcLTauCaloSpecific_Dictionary();
   static void patcLcLtaucLcLTauCaloSpecific_TClassManip(TClass*);
   static void *new_patcLcLtaucLcLTauCaloSpecific(void *p = 0);
   static void *newArray_patcLcLtaucLcLTauCaloSpecific(Long_t size, void *p);
   static void delete_patcLcLtaucLcLTauCaloSpecific(void *p);
   static void deleteArray_patcLcLtaucLcLTauCaloSpecific(void *p);
   static void destruct_patcLcLtaucLcLTauCaloSpecific(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::tau::TauCaloSpecific*)
   {
      ::pat::tau::TauCaloSpecific *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::tau::TauCaloSpecific));
      static ::ROOT::TGenericClassInfo 
         instance("pat::tau::TauCaloSpecific", 11, "DataFormats/PatCandidates/interface/TauCaloSpecific.h", 19,
                  typeid(::pat::tau::TauCaloSpecific), DefineBehavior(ptr, ptr),
                  &patcLcLtaucLcLTauCaloSpecific_Dictionary, isa_proxy, 8,
                  sizeof(::pat::tau::TauCaloSpecific) );
      instance.SetNew(&new_patcLcLtaucLcLTauCaloSpecific);
      instance.SetNewArray(&newArray_patcLcLtaucLcLTauCaloSpecific);
      instance.SetDelete(&delete_patcLcLtaucLcLTauCaloSpecific);
      instance.SetDeleteArray(&deleteArray_patcLcLtaucLcLTauCaloSpecific);
      instance.SetDestructor(&destruct_patcLcLtaucLcLTauCaloSpecific);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::tau::TauCaloSpecific*)
   {
      return GenerateInitInstanceLocal((::pat::tau::TauCaloSpecific*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::tau::TauCaloSpecific*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLtaucLcLTauCaloSpecific_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::tau::TauCaloSpecific*)0x0)->GetClass();
      patcLcLtaucLcLTauCaloSpecific_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLtaucLcLTauCaloSpecific_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLtaucLcLTauPFEssential_Dictionary();
   static void patcLcLtaucLcLTauPFEssential_TClassManip(TClass*);
   static void *new_patcLcLtaucLcLTauPFEssential(void *p = 0);
   static void *newArray_patcLcLtaucLcLTauPFEssential(Long_t size, void *p);
   static void delete_patcLcLtaucLcLTauPFEssential(void *p);
   static void deleteArray_patcLcLtaucLcLTauPFEssential(void *p);
   static void destruct_patcLcLtaucLcLTauPFEssential(void *p);

   // Schema evolution read functions
   static void read_patcLcLtaucLcLTauPFEssential_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_p4Jet_ = oldObj->GetId("p4Jet_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > &p4Jet_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > &onfile_p4Jet_ ): p4Jet_(onfile_p4Jet_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_p4Jet_ = oldObj->GetClass()->GetDataMemberOffset("p4Jet_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_p4Jet_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_p4Jet_ = cls->GetDataMemberOffset("p4Jet_");
      pat::tau::TauPFEssential::LorentzVector& p4Jet_ = *(pat::tau::TauPFEssential::LorentzVector*)(target+offset_p4Jet_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      p4Jet_ = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<float> >(onfile.p4Jet_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_p4CorrJet_ = oldObj->GetId("p4CorrJet_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > &p4CorrJet_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > &onfile_p4CorrJet_ ): p4CorrJet_(onfile_p4CorrJet_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_p4CorrJet_ = oldObj->GetClass()->GetDataMemberOffset("p4CorrJet_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_p4CorrJet_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_p4CorrJet_ = cls->GetDataMemberOffset("p4CorrJet_");
      pat::tau::TauPFEssential::LorentzVector& p4CorrJet_ = *(pat::tau::TauPFEssential::LorentzVector*)(target+offset_p4CorrJet_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      p4CorrJet_ = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<float> >(onfile.p4CorrJet_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_dxy_PCA_ = oldObj->GetId("dxy_PCA_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &dxy_PCA_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &onfile_dxy_PCA_ ): dxy_PCA_(onfile_dxy_PCA_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_dxy_PCA_ = oldObj->GetClass()->GetDataMemberOffset("dxy_PCA_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_dxy_PCA_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_dxy_PCA_ = cls->GetDataMemberOffset("dxy_PCA_");
      pat::tau::TauPFEssential::Point& dxy_PCA_ = *(pat::tau::TauPFEssential::Point*)(target+offset_dxy_PCA_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      dxy_PCA_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.dxy_PCA_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_3( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_pvPos_ = oldObj->GetId("pvPos_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &pvPos_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &onfile_pvPos_ ): pvPos_(onfile_pvPos_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_pvPos_ = oldObj->GetClass()->GetDataMemberOffset("pvPos_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_pvPos_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_pvPos_ = cls->GetDataMemberOffset("pvPos_");
      pat::tau::TauPFEssential::Point& pvPos_ = *(pat::tau::TauPFEssential::Point*)(target+offset_pvPos_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      pvPos_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.pvPos_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_4( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_pvCov_ = oldObj->GetId("pvCov_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > &pvCov_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > &onfile_pvCov_ ): pvCov_(onfile_pvCov_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_pvCov_ = oldObj->GetClass()->GetDataMemberOffset("pvCov_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_pvCov_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_pvCov_ = cls->GetDataMemberOffset("pvCov_");
      pat::tau::TauPFEssential::CovMatrix& pvCov_ = *(pat::tau::TauPFEssential::CovMatrix*)(target+offset_pvCov_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     
       // matrices must be copied by hand
       for (unsigned int i = 0; i < 3; ++i) { for (unsigned int j = 0; j < 3; ++j) {
            pvCov_(i,j) = onfile.pvCov_(i,j);
       }}
    
   }
   static void read_patcLcLtaucLcLTauPFEssential_5( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_flightLength_ = oldObj->GetId("flightLength_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &flightLength_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &onfile_flightLength_ ): flightLength_(onfile_flightLength_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_flightLength_ = oldObj->GetClass()->GetDataMemberOffset("flightLength_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_flightLength_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_flightLength_ = cls->GetDataMemberOffset("flightLength_");
      pat::tau::TauPFEssential::Vector& flightLength_ = *(pat::tau::TauPFEssential::Vector*)(target+offset_flightLength_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      flightLength_ = ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.flightLength_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_6( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_svPos_ = oldObj->GetId("svPos_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &svPos_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> &onfile_svPos_ ): svPos_(onfile_svPos_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_svPos_ = oldObj->GetClass()->GetDataMemberOffset("svPos_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_svPos_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_svPos_ = cls->GetDataMemberOffset("svPos_");
      pat::tau::TauPFEssential::Point& svPos_ = *(pat::tau::TauPFEssential::Point*)(target+offset_svPos_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
      svPos_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.svPos_); 
   }
   static void read_patcLcLtaucLcLTauPFEssential_7( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_svCov_ = oldObj->GetId("svCov_");
#endif
      struct patcLcLtaucLcLTauPFEssential_Onfile {
         ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > &svCov_;
         patcLcLtaucLcLTauPFEssential_Onfile(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > &onfile_svCov_ ): svCov_(onfile_svCov_) {}
      };
      static Long_t offset_Onfile_patcLcLtaucLcLTauPFEssential_svCov_ = oldObj->GetClass()->GetDataMemberOffset("svCov_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLtaucLcLTauPFEssential_Onfile onfile(
         *(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)(onfile_add+offset_Onfile_patcLcLtaucLcLTauPFEssential_svCov_) );

      static TClassRef cls("pat::tau::TauPFEssential");
      static Long_t offset_svCov_ = cls->GetDataMemberOffset("svCov_");
      pat::tau::TauPFEssential::CovMatrix& svCov_ = *(pat::tau::TauPFEssential::CovMatrix*)(target+offset_svCov_);
      pat::tau::TauPFEssential* newObj = (pat::tau::TauPFEssential*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     
       // matrices must be copied by hand
       for (unsigned int i = 0; i < 3; ++i) { for (unsigned int j = 0; j < 3; ++j) {
            svCov_(i,j) = onfile.svCov_(i,j);
       }}
    
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::tau::TauPFEssential*)
   {
      ::pat::tau::TauPFEssential *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::tau::TauPFEssential));
      static ::ROOT::TGenericClassInfo 
         instance("pat::tau::TauPFEssential", 11, "DataFormats/PatCandidates/interface/TauPFEssential.h", 21,
                  typeid(::pat::tau::TauPFEssential), DefineBehavior(ptr, ptr),
                  &patcLcLtaucLcLTauPFEssential_Dictionary, isa_proxy, 8,
                  sizeof(::pat::tau::TauPFEssential) );
      instance.SetNew(&new_patcLcLtaucLcLTauPFEssential);
      instance.SetNewArray(&newArray_patcLcLtaucLcLTauPFEssential);
      instance.SetDelete(&delete_patcLcLtaucLcLTauPFEssential);
      instance.SetDeleteArray(&deleteArray_patcLcLtaucLcLTauPFEssential);
      instance.SetDestructor(&destruct_patcLcLtaucLcLTauPFEssential);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(8);
      rule = &readrules[0];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "p4Jet_";
      rule->fSource      = "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > p4Jet_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_0);
      rule->fCode        = " p4Jet_ = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<float> >(onfile.p4Jet_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[1];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "p4CorrJet_";
      rule->fSource      = "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > p4CorrJet_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_1);
      rule->fCode        = " p4CorrJet_ = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<float> >(onfile.p4CorrJet_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[2];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "dxy_PCA_";
      rule->fSource      = "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> dxy_PCA_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_2);
      rule->fCode        = " dxy_PCA_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.dxy_PCA_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[3];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "pvPos_";
      rule->fSource      = "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> pvPos_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_3);
      rule->fCode        = " pvPos_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.pvPos_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[4];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "pvCov_";
      rule->fSource      = "ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > pvCov_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_4);
      rule->fCode        = "\n       // matrices must be copied by hand\n       for (unsigned int i = 0; i < 3; ++i) { for (unsigned int j = 0; j < 3; ++j) {\n            pvCov_(i,j) = onfile.pvCov_(i,j);\n       }}\n    ";
      rule->fVersion     = "[-10]";
      rule = &readrules[5];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "flightLength_";
      rule->fSource      = "ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> flightLength_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_5);
      rule->fCode        = " flightLength_ = ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.flightLength_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[6];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "svPos_";
      rule->fSource      = "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> svPos_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_6);
      rule->fCode        = " svPos_ = ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(onfile.svPos_); ";
      rule->fVersion     = "[-10]";
      rule = &readrules[7];
      rule->fSourceClass = "pat::tau::TauPFEssential";
      rule->fTarget      = "svCov_";
      rule->fSource      = "ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > svCov_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLtaucLcLTauPFEssential_7);
      rule->fCode        = "\n       // matrices must be copied by hand\n       for (unsigned int i = 0; i < 3; ++i) { for (unsigned int j = 0; j < 3; ++j) {\n            svCov_(i,j) = onfile.svCov_(i,j);\n       }}\n    ";
      rule->fVersion     = "[-10]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::tau::TauPFEssential*)
   {
      return GenerateInitInstanceLocal((::pat::tau::TauPFEssential*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::tau::TauPFEssential*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLtaucLcLTauPFEssential_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::tau::TauPFEssential*)0x0)->GetClass();
      patcLcLtaucLcLTauPFEssential_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLtaucLcLTauPFEssential_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPhoton_Dictionary();
   static void patcLcLPhoton_TClassManip(TClass*);
   static void *new_patcLcLPhoton(void *p = 0);
   static void *newArray_patcLcLPhoton(Long_t size, void *p);
   static void delete_patcLcLPhoton(void *p);
   static void deleteArray_patcLcLPhoton(void *p);
   static void destruct_patcLcLPhoton(void *p);

   // Schema evolution read functions
   static void read_patcLcLPhoton_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::Photon");
      static Long_t offset_superClusterRelinked_ = cls->GetDataMemberOffset("superClusterRelinked_");
      edm::AtomicPtrCache<vector<reco::SuperCluster> >& superClusterRelinked_ = *(edm::AtomicPtrCache<vector<reco::SuperCluster> >*)(target+offset_superClusterRelinked_);
      pat::Photon* newObj = (pat::Photon*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     superClusterRelinked_.reset();
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Photon*)
   {
      ::pat::Photon *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Photon));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Photon", 18, "DataFormats/PatCandidates/interface/Photon.h", 47,
                  typeid(::pat::Photon), DefineBehavior(ptr, ptr),
                  &patcLcLPhoton_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Photon) );
      instance.SetNew(&new_patcLcLPhoton);
      instance.SetNewArray(&newArray_patcLcLPhoton);
      instance.SetDelete(&delete_patcLcLPhoton);
      instance.SetDeleteArray(&deleteArray_patcLcLPhoton);
      instance.SetDestructor(&destruct_patcLcLPhoton);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "pat::Photon";
      rule->fTarget      = "superClusterRelinked_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPhoton_0);
      rule->fCode        = "superClusterRelinked_.reset();";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Photon*)
   {
      return GenerateInitInstanceLocal((::pat::Photon*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Photon*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPhoton_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Photon*)0x0)->GetClass();
      patcLcLPhoton_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPhoton_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLJet_Dictionary();
   static void patcLcLJet_TClassManip(TClass*);
   static void *new_patcLcLJet(void *p = 0);
   static void *newArray_patcLcLJet(Long_t size, void *p);
   static void delete_patcLcLJet(void *p);
   static void deleteArray_patcLcLJet(void *p);
   static void destruct_patcLcLJet(void *p);

   // Schema evolution read functions
   static void read_patcLcLJet_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_partonFlavour_ = oldObj->GetId("partonFlavour_");
#endif
      struct patcLcLJet_Onfile {
         int &partonFlavour_;
         patcLcLJet_Onfile(int &onfile_partonFlavour_ ): partonFlavour_(onfile_partonFlavour_) {}
      };
      static Long_t offset_Onfile_patcLcLJet_partonFlavour_ = oldObj->GetClass()->GetDataMemberOffset("partonFlavour_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLJet_Onfile onfile(
         *(int*)(onfile_add+offset_Onfile_patcLcLJet_partonFlavour_) );

      static TClassRef cls("pat::Jet");
      static Long_t offset_jetFlavourInfo_ = cls->GetDataMemberOffset("jetFlavourInfo_");
      reco::JetFlavourInfo& jetFlavourInfo_ = *(reco::JetFlavourInfo*)(target+offset_jetFlavourInfo_);
      pat::Jet* newObj = (pat::Jet*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     jetFlavourInfo_ = reco::JetFlavourInfo(0,onfile.partonFlavour_);
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Jet*)
   {
      ::pat::Jet *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Jet));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Jet", 16, "DataFormats/PatCandidates/interface/Jet.h", 77,
                  typeid(::pat::Jet), DefineBehavior(ptr, ptr),
                  &patcLcLJet_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Jet) );
      instance.SetNew(&new_patcLcLJet);
      instance.SetNewArray(&newArray_patcLcLJet);
      instance.SetDelete(&delete_patcLcLJet);
      instance.SetDeleteArray(&deleteArray_patcLcLJet);
      instance.SetDestructor(&destruct_patcLcLJet);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "pat::Jet";
      rule->fTarget      = "jetFlavourInfo_";
      rule->fSource      = "int partonFlavour_";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLJet_0);
      rule->fCode        = "jetFlavourInfo_ = reco::JetFlavourInfo(0,onfile.partonFlavour_);";
      rule->fVersion     = "[1-11]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Jet*)
   {
      return GenerateInitInstanceLocal((::pat::Jet*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Jet*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLJet_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Jet*)0x0)->GetClass();
      patcLcLJet_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLJet_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLMET_Dictionary();
   static void patcLcLMET_TClassManip(TClass*);
   static void *new_patcLcLMET(void *p = 0);
   static void *newArray_patcLcLMET(Long_t size, void *p);
   static void delete_patcLcLMET(void *p);
   static void deleteArray_patcLcLMET(void *p);
   static void destruct_patcLcLMET(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::MET*)
   {
      ::pat::MET *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::MET));
      static ::ROOT::TGenericClassInfo 
         instance("pat::MET", 14, "DataFormats/PatCandidates/interface/MET.h", 43,
                  typeid(::pat::MET), DefineBehavior(ptr, ptr),
                  &patcLcLMET_Dictionary, isa_proxy, 8,
                  sizeof(::pat::MET) );
      instance.SetNew(&new_patcLcLMET);
      instance.SetNewArray(&newArray_patcLcLMET);
      instance.SetDelete(&delete_patcLcLMET);
      instance.SetDeleteArray(&deleteArray_patcLcLMET);
      instance.SetDestructor(&destruct_patcLcLMET);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::MET*)
   {
      return GenerateInitInstanceLocal((::pat::MET*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::MET*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLMET_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::MET*)0x0)->GetClass();
      patcLcLMET_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLMET_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLMETcLcLPackedMETUncertainty_Dictionary();
   static void patcLcLMETcLcLPackedMETUncertainty_TClassManip(TClass*);
   static void *new_patcLcLMETcLcLPackedMETUncertainty(void *p = 0);
   static void *newArray_patcLcLMETcLcLPackedMETUncertainty(Long_t size, void *p);
   static void delete_patcLcLMETcLcLPackedMETUncertainty(void *p);
   static void deleteArray_patcLcLMETcLcLPackedMETUncertainty(void *p);
   static void destruct_patcLcLMETcLcLPackedMETUncertainty(void *p);

   // Schema evolution read functions
   static void read_patcLcLMETcLcLPackedMETUncertainty_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::MET::PackedMETUncertainty");
      static Long_t offset_unpacked_ = cls->GetDataMemberOffset("unpacked_");
      bool& unpacked_ = *(bool*)(target+offset_unpacked_);
      pat::MET::PackedMETUncertainty* newObj = (pat::MET::PackedMETUncertainty*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     unpacked_ = false; 
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::MET::PackedMETUncertainty*)
   {
      ::pat::MET::PackedMETUncertainty *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::MET::PackedMETUncertainty));
      static ::ROOT::TGenericClassInfo 
         instance("pat::MET::PackedMETUncertainty", 11, "DataFormats/PatCandidates/interface/MET.h", 176,
                  typeid(::pat::MET::PackedMETUncertainty), DefineBehavior(ptr, ptr),
                  &patcLcLMETcLcLPackedMETUncertainty_Dictionary, isa_proxy, 8,
                  sizeof(::pat::MET::PackedMETUncertainty) );
      instance.SetNew(&new_patcLcLMETcLcLPackedMETUncertainty);
      instance.SetNewArray(&newArray_patcLcLMETcLcLPackedMETUncertainty);
      instance.SetDelete(&delete_patcLcLMETcLcLPackedMETUncertainty);
      instance.SetDeleteArray(&deleteArray_patcLcLMETcLcLPackedMETUncertainty);
      instance.SetDestructor(&destruct_patcLcLMETcLcLPackedMETUncertainty);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(1);
      rule = &readrules[0];
      rule->fSourceClass = "pat::MET::PackedMETUncertainty";
      rule->fTarget      = "unpacked_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLMETcLcLPackedMETUncertainty_0);
      rule->fCode        = "unpacked_ = false; ";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::MET::PackedMETUncertainty*)
   {
      return GenerateInitInstanceLocal((::pat::MET::PackedMETUncertainty*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::MET::PackedMETUncertainty*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLMETcLcLPackedMETUncertainty_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::MET::PackedMETUncertainty*)0x0)->GetClass();
      patcLcLMETcLcLPackedMETUncertainty_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLMETcLcLPackedMETUncertainty_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLMETcLcLVector2_Dictionary();
   static void patcLcLMETcLcLVector2_TClassManip(TClass*);
   static void *new_patcLcLMETcLcLVector2(void *p = 0);
   static void *newArray_patcLcLMETcLcLVector2(Long_t size, void *p);
   static void delete_patcLcLMETcLcLVector2(void *p);
   static void deleteArray_patcLcLMETcLcLVector2(void *p);
   static void destruct_patcLcLMETcLcLVector2(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::MET::Vector2*)
   {
      ::pat::MET::Vector2 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::MET::Vector2));
      static ::ROOT::TGenericClassInfo 
         instance("pat::MET::Vector2", "DataFormats/PatCandidates/interface/MET.h", 150,
                  typeid(::pat::MET::Vector2), DefineBehavior(ptr, ptr),
                  &patcLcLMETcLcLVector2_Dictionary, isa_proxy, 0,
                  sizeof(::pat::MET::Vector2) );
      instance.SetNew(&new_patcLcLMETcLcLVector2);
      instance.SetNewArray(&newArray_patcLcLMETcLcLVector2);
      instance.SetDelete(&delete_patcLcLMETcLcLVector2);
      instance.SetDeleteArray(&deleteArray_patcLcLMETcLcLVector2);
      instance.SetDestructor(&destruct_patcLcLMETcLcLVector2);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::MET::Vector2*)
   {
      return GenerateInitInstanceLocal((::pat::MET::Vector2*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::MET::Vector2*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLMETcLcLVector2_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::MET::Vector2*)0x0)->GetClass();
      patcLcLMETcLcLVector2_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLMETcLcLVector2_TClassManip(TClass* theClass){
      theClass->CreateAttributeMap();
      TDictAttributeMap* attrMap( theClass->GetAttributeMap() );
      attrMap->AddProperty("transient","true");
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLMHT_Dictionary();
   static void patcLcLMHT_TClassManip(TClass*);
   static void *new_patcLcLMHT(void *p = 0);
   static void *newArray_patcLcLMHT(Long_t size, void *p);
   static void delete_patcLcLMHT(void *p);
   static void deleteArray_patcLcLMHT(void *p);
   static void destruct_patcLcLMHT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::MHT*)
   {
      ::pat::MHT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::MHT));
      static ::ROOT::TGenericClassInfo 
         instance("pat::MHT", 12, "DataFormats/PatCandidates/interface/MHT.h", 10,
                  typeid(::pat::MHT), DefineBehavior(ptr, ptr),
                  &patcLcLMHT_Dictionary, isa_proxy, 8,
                  sizeof(::pat::MHT) );
      instance.SetNew(&new_patcLcLMHT);
      instance.SetNewArray(&newArray_patcLcLMHT);
      instance.SetDelete(&delete_patcLcLMHT);
      instance.SetDeleteArray(&deleteArray_patcLcLMHT);
      instance.SetDestructor(&destruct_patcLcLMHT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::MHT*)
   {
      return GenerateInitInstanceLocal((::pat::MHT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::MHT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLMHT_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::MHT*)0x0)->GetClass();
      patcLcLMHT_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLMHT_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLParticle_Dictionary();
   static void patcLcLParticle_TClassManip(TClass*);
   static void *new_patcLcLParticle(void *p = 0);
   static void *newArray_patcLcLParticle(Long_t size, void *p);
   static void delete_patcLcLParticle(void *p);
   static void deleteArray_patcLcLParticle(void *p);
   static void destruct_patcLcLParticle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Particle*)
   {
      ::pat::Particle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Particle));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Particle", 12, "DataFormats/PatCandidates/interface/Particle.h", 32,
                  typeid(::pat::Particle), DefineBehavior(ptr, ptr),
                  &patcLcLParticle_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Particle) );
      instance.SetNew(&new_patcLcLParticle);
      instance.SetNewArray(&newArray_patcLcLParticle);
      instance.SetDelete(&delete_patcLcLParticle);
      instance.SetDeleteArray(&deleteArray_patcLcLParticle);
      instance.SetDestructor(&destruct_patcLcLParticle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Particle*)
   {
      return GenerateInitInstanceLocal((::pat::Particle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Particle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Particle*)0x0)->GetClass();
      patcLcLParticle_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLCompositeCandidate_Dictionary();
   static void patcLcLCompositeCandidate_TClassManip(TClass*);
   static void *new_patcLcLCompositeCandidate(void *p = 0);
   static void *newArray_patcLcLCompositeCandidate(Long_t size, void *p);
   static void delete_patcLcLCompositeCandidate(void *p);
   static void deleteArray_patcLcLCompositeCandidate(void *p);
   static void destruct_patcLcLCompositeCandidate(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::CompositeCandidate*)
   {
      ::pat::CompositeCandidate *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::CompositeCandidate));
      static ::ROOT::TGenericClassInfo 
         instance("pat::CompositeCandidate", 12, "DataFormats/PatCandidates/interface/CompositeCandidate.h", 34,
                  typeid(::pat::CompositeCandidate), DefineBehavior(ptr, ptr),
                  &patcLcLCompositeCandidate_Dictionary, isa_proxy, 8,
                  sizeof(::pat::CompositeCandidate) );
      instance.SetNew(&new_patcLcLCompositeCandidate);
      instance.SetNewArray(&newArray_patcLcLCompositeCandidate);
      instance.SetDelete(&delete_patcLcLCompositeCandidate);
      instance.SetDeleteArray(&deleteArray_patcLcLCompositeCandidate);
      instance.SetDestructor(&destruct_patcLcLCompositeCandidate);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::CompositeCandidate*)
   {
      return GenerateInitInstanceLocal((::pat::CompositeCandidate*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::CompositeCandidate*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLCompositeCandidate_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::CompositeCandidate*)0x0)->GetClass();
      patcLcLCompositeCandidate_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLCompositeCandidate_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPFParticle_Dictionary();
   static void patcLcLPFParticle_TClassManip(TClass*);
   static void *new_patcLcLPFParticle(void *p = 0);
   static void *newArray_patcLcLPFParticle(Long_t size, void *p);
   static void delete_patcLcLPFParticle(void *p);
   static void deleteArray_patcLcLPFParticle(void *p);
   static void destruct_patcLcLPFParticle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PFParticle*)
   {
      ::pat::PFParticle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PFParticle));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PFParticle", 13, "DataFormats/PatCandidates/interface/PFParticle.h", 35,
                  typeid(::pat::PFParticle), DefineBehavior(ptr, ptr),
                  &patcLcLPFParticle_Dictionary, isa_proxy, 8,
                  sizeof(::pat::PFParticle) );
      instance.SetNew(&new_patcLcLPFParticle);
      instance.SetNewArray(&newArray_patcLcLPFParticle);
      instance.SetDelete(&delete_patcLcLPFParticle);
      instance.SetDeleteArray(&deleteArray_patcLcLPFParticle);
      instance.SetDestructor(&destruct_patcLcLPFParticle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PFParticle*)
   {
      return GenerateInitInstanceLocal((::pat::PFParticle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PFParticle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPFParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PFParticle*)0x0)->GetClass();
      patcLcLPFParticle_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPFParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLGenericParticle_Dictionary();
   static void patcLcLGenericParticle_TClassManip(TClass*);
   static void *new_patcLcLGenericParticle(void *p = 0);
   static void *newArray_patcLcLGenericParticle(Long_t size, void *p);
   static void delete_patcLcLGenericParticle(void *p);
   static void deleteArray_patcLcLGenericParticle(void *p);
   static void destruct_patcLcLGenericParticle(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::GenericParticle*)
   {
      ::pat::GenericParticle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::GenericParticle));
      static ::ROOT::TGenericClassInfo 
         instance("pat::GenericParticle", 12, "DataFormats/PatCandidates/interface/GenericParticle.h", 40,
                  typeid(::pat::GenericParticle), DefineBehavior(ptr, ptr),
                  &patcLcLGenericParticle_Dictionary, isa_proxy, 8,
                  sizeof(::pat::GenericParticle) );
      instance.SetNew(&new_patcLcLGenericParticle);
      instance.SetNewArray(&newArray_patcLcLGenericParticle);
      instance.SetDelete(&delete_patcLcLGenericParticle);
      instance.SetDeleteArray(&deleteArray_patcLcLGenericParticle);
      instance.SetDestructor(&destruct_patcLcLGenericParticle);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::GenericParticle*)
   {
      return GenerateInitInstanceLocal((::pat::GenericParticle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::GenericParticle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLGenericParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::GenericParticle*)0x0)->GetClass();
      patcLcLGenericParticle_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLGenericParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLHemisphere_Dictionary();
   static void patcLcLHemisphere_TClassManip(TClass*);
   static void *new_patcLcLHemisphere(void *p = 0);
   static void *newArray_patcLcLHemisphere(Long_t size, void *p);
   static void delete_patcLcLHemisphere(void *p);
   static void deleteArray_patcLcLHemisphere(void *p);
   static void destruct_patcLcLHemisphere(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Hemisphere*)
   {
      ::pat::Hemisphere *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Hemisphere));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Hemisphere", 12, "DataFormats/PatCandidates/interface/Hemisphere.h", 17,
                  typeid(::pat::Hemisphere), DefineBehavior(ptr, ptr),
                  &patcLcLHemisphere_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Hemisphere) );
      instance.SetNew(&new_patcLcLHemisphere);
      instance.SetNewArray(&newArray_patcLcLHemisphere);
      instance.SetDelete(&delete_patcLcLHemisphere);
      instance.SetDeleteArray(&deleteArray_patcLcLHemisphere);
      instance.SetDestructor(&destruct_patcLcLHemisphere);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Hemisphere*)
   {
      return GenerateInitInstanceLocal((::pat::Hemisphere*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Hemisphere*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLHemisphere_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Hemisphere*)0x0)->GetClass();
      patcLcLHemisphere_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLHemisphere_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLConversion_Dictionary();
   static void patcLcLConversion_TClassManip(TClass*);
   static void *new_patcLcLConversion(void *p = 0);
   static void *newArray_patcLcLConversion(Long_t size, void *p);
   static void delete_patcLcLConversion(void *p);
   static void deleteArray_patcLcLConversion(void *p);
   static void destruct_patcLcLConversion(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::Conversion*)
   {
      ::pat::Conversion *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::Conversion));
      static ::ROOT::TGenericClassInfo 
         instance("pat::Conversion", 11, "DataFormats/PatCandidates/interface/Conversion.h", 22,
                  typeid(::pat::Conversion), DefineBehavior(ptr, ptr),
                  &patcLcLConversion_Dictionary, isa_proxy, 8,
                  sizeof(::pat::Conversion) );
      instance.SetNew(&new_patcLcLConversion);
      instance.SetNewArray(&newArray_patcLcLConversion);
      instance.SetDelete(&delete_patcLcLConversion);
      instance.SetDeleteArray(&deleteArray_patcLcLConversion);
      instance.SetDestructor(&destruct_patcLcLConversion);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::Conversion*)
   {
      return GenerateInitInstanceLocal((::pat::Conversion*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::Conversion*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLConversion_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::Conversion*)0x0)->GetClass();
      patcLcLConversion_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLConversion_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPackedCandidate_Dictionary();
   static void patcLcLPackedCandidate_TClassManip(TClass*);
   static void *new_patcLcLPackedCandidate(void *p = 0);
   static void *newArray_patcLcLPackedCandidate(Long_t size, void *p);
   static void delete_patcLcLPackedCandidate(void *p);
   static void deleteArray_patcLcLPackedCandidate(void *p);
   static void destruct_patcLcLPackedCandidate(void *p);

   // Schema evolution read functions
   static void read_patcLcLPackedCandidate_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::PackedCandidate");
      static Long_t offset_unpacked_ = cls->GetDataMemberOffset("unpacked_");
      bool& unpacked_ = *(bool*)(target+offset_unpacked_);
      pat::PackedCandidate* newObj = (pat::PackedCandidate*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     unpacked_ = false;
    
   }
   static void read_patcLcLPackedCandidate_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::PackedCandidate");
      static Long_t offset_unpackedVtx_ = cls->GetDataMemberOffset("unpackedVtx_");
      bool& unpackedVtx_ = *(bool*)(target+offset_unpackedVtx_);
      pat::PackedCandidate* newObj = (pat::PackedCandidate*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     unpackedVtx_ = false;
    
   }
   static void read_patcLcLPackedCandidate_2( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::PackedCandidate");
      static Long_t offset_unpackedTrk_ = cls->GetDataMemberOffset("unpackedTrk_");
      bool& unpackedTrk_ = *(bool*)(target+offset_unpackedTrk_);
      pat::PackedCandidate* newObj = (pat::PackedCandidate*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     unpackedTrk_ = false;
    
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PackedCandidate*)
   {
      ::pat::PackedCandidate *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PackedCandidate));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PackedCandidate", 18, "DataFormats/PatCandidates/interface/PackedCandidate.h", 14,
                  typeid(::pat::PackedCandidate), DefineBehavior(ptr, ptr),
                  &patcLcLPackedCandidate_Dictionary, isa_proxy, 8,
                  sizeof(::pat::PackedCandidate) );
      instance.SetNew(&new_patcLcLPackedCandidate);
      instance.SetNewArray(&newArray_patcLcLPackedCandidate);
      instance.SetDelete(&delete_patcLcLPackedCandidate);
      instance.SetDeleteArray(&deleteArray_patcLcLPackedCandidate);
      instance.SetDestructor(&destruct_patcLcLPackedCandidate);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(3);
      rule = &readrules[0];
      rule->fSourceClass = "pat::PackedCandidate";
      rule->fTarget      = "unpacked_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPackedCandidate_0);
      rule->fCode        = "unpacked_ = false;\n    ";
      rule->fVersion     = "[1-]";
      rule = &readrules[1];
      rule->fSourceClass = "pat::PackedCandidate";
      rule->fTarget      = "unpackedVtx_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPackedCandidate_1);
      rule->fCode        = "unpackedVtx_ = false;\n    ";
      rule->fVersion     = "[1-]";
      rule = &readrules[2];
      rule->fSourceClass = "pat::PackedCandidate";
      rule->fTarget      = "unpackedTrk_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPackedCandidate_2);
      rule->fCode        = "unpackedTrk_ = false;\n    ";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PackedCandidate*)
   {
      return GenerateInitInstanceLocal((::pat::PackedCandidate*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PackedCandidate*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPackedCandidate_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PackedCandidate*)0x0)->GetClass();
      patcLcLPackedCandidate_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPackedCandidate_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *patcLcLPackedGenParticle_Dictionary();
   static void patcLcLPackedGenParticle_TClassManip(TClass*);
   static void *new_patcLcLPackedGenParticle(void *p = 0);
   static void *newArray_patcLcLPackedGenParticle(Long_t size, void *p);
   static void delete_patcLcLPackedGenParticle(void *p);
   static void deleteArray_patcLcLPackedGenParticle(void *p);
   static void destruct_patcLcLPackedGenParticle(void *p);

   // Schema evolution read functions
   static void read_patcLcLPackedGenParticle_0( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
#if 0
      static Int_t id_packedEta_ = oldObj->GetId("packedEta_");
      static Int_t id_packedPt_ = oldObj->GetId("packedPt_");
      static Int_t id_packedM_ = oldObj->GetId("packedM_");
#endif
      struct patcLcLPackedGenParticle_Onfile {
         int16_t &packedEta_;
         int16_t &packedPt_;
         int16_t &packedM_;
         patcLcLPackedGenParticle_Onfile(int16_t &onfile_packedEta_, int16_t &onfile_packedPt_, int16_t &onfile_packedM_ ): packedEta_(onfile_packedEta_), packedPt_(onfile_packedPt_), packedM_(onfile_packedM_) {}
      };
      static Long_t offset_Onfile_patcLcLPackedGenParticle_packedEta_ = oldObj->GetClass()->GetDataMemberOffset("packedEta_");
      static Long_t offset_Onfile_patcLcLPackedGenParticle_packedPt_ = oldObj->GetClass()->GetDataMemberOffset("packedPt_");
      static Long_t offset_Onfile_patcLcLPackedGenParticle_packedM_ = oldObj->GetClass()->GetDataMemberOffset("packedM_");
      char *onfile_add = (char*)oldObj->GetObject();
      patcLcLPackedGenParticle_Onfile onfile(
         *(int16_t*)(onfile_add+offset_Onfile_patcLcLPackedGenParticle_packedEta_),
         *(int16_t*)(onfile_add+offset_Onfile_patcLcLPackedGenParticle_packedPt_),
         *(int16_t*)(onfile_add+offset_Onfile_patcLcLPackedGenParticle_packedM_) );

      static TClassRef cls("pat::PackedGenParticle");
      static Long_t offset_packedY_ = cls->GetDataMemberOffset("packedY_");
      uint16_t& packedY_ = *(uint16_t*)(target+offset_packedY_);
      pat::PackedGenParticle* newObj = (pat::PackedGenParticle*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     
	packedY_ = convertPackedEtaToPackedY(onfile.packedPt_,onfile.packedEta_,onfile.packedM_);
	
   }
   static void read_patcLcLPackedGenParticle_1( char* target, TVirtualObject *oldObj )
   {
      //--- Automatically generated variables ---
      static TClassRef cls("pat::PackedGenParticle");
      static Long_t offset_unpacked_ = cls->GetDataMemberOffset("unpacked_");
      bool& unpacked_ = *(bool*)(target+offset_unpacked_);
      pat::PackedGenParticle* newObj = (pat::PackedGenParticle*)target;
      // Supress warning message.
      if (oldObj) {}

      if (newObj) {}

      //--- User's code ---
     unpacked_ = false;
    
   }

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::pat::PackedGenParticle*)
   {
      ::pat::PackedGenParticle *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::pat::PackedGenParticle));
      static ::ROOT::TGenericClassInfo 
         instance("pat::PackedGenParticle", 12, "DataFormats/PatCandidates/interface/PackedGenParticle.h", 17,
                  typeid(::pat::PackedGenParticle), DefineBehavior(ptr, ptr),
                  &patcLcLPackedGenParticle_Dictionary, isa_proxy, 8,
                  sizeof(::pat::PackedGenParticle) );
      instance.SetNew(&new_patcLcLPackedGenParticle);
      instance.SetNewArray(&newArray_patcLcLPackedGenParticle);
      instance.SetDelete(&delete_patcLcLPackedGenParticle);
      instance.SetDeleteArray(&deleteArray_patcLcLPackedGenParticle);
      instance.SetDestructor(&destruct_patcLcLPackedGenParticle);

      ROOT::TSchemaHelper* rule;

      // the io read rules
      std::vector<ROOT::TSchemaHelper> readrules(2);
      rule = &readrules[0];
      rule->fSourceClass = "pat::PackedGenParticle";
      rule->fTarget      = "packedY_";
      rule->fSource      = "int16_t packedEta_;int16_t packedPt_;int16_t packedM_;";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPackedGenParticle_0);
      rule->fCode        = "\n	packedY_ = convertPackedEtaToPackedY(onfile.packedPt_,onfile.packedEta_,onfile.packedM_);\n	";
      rule->fVersion     = "[-10]";
      rule->fChecksum    = "[389883266]";
      rule->fEmbed       = false;
      rule->fInclude     = "DataFormats/PatCandidates/interface/ioread_packedgen.h";
      rule = &readrules[1];
      rule->fSourceClass = "pat::PackedGenParticle";
      rule->fTarget      = "unpacked_";
      rule->fSource      = "";
      rule->fFunctionPtr = (void *)TFunc2void( read_patcLcLPackedGenParticle_1);
      rule->fCode        = "unpacked_ = false;\n    ";
      rule->fVersion     = "[1-]";
      instance.SetReadRules( readrules );
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::pat::PackedGenParticle*)
   {
      return GenerateInitInstanceLocal((::pat::PackedGenParticle*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::pat::PackedGenParticle*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *patcLcLPackedGenParticle_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::pat::PackedGenParticle*)0x0)->GetClass();
      patcLcLPackedGenParticle_TClassManip(theClass);
   return theClass;
   }

   static void patcLcLPackedGenParticle_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLElectrongR_Dictionary();
   static void edmcLcLPtrlEpatcLcLElectrongR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLElectrongR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLElectrongR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLElectrongR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLElectrongR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLElectrongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::Electron>*)
   {
      ::edm::Ptr<pat::Electron> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::Electron>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::Electron>", ::edm::Ptr<pat::Electron>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::Electron>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLElectrongR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::Electron>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLElectrongR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLElectrongR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLElectrongR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLElectrongR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLElectrongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::Electron>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::Electron>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::Electron>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLElectrongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::Electron>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLElectrongR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLElectrongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLMuongR_Dictionary();
   static void edmcLcLPtrlEpatcLcLMuongR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLMuongR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLMuongR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLMuongR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLMuongR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLMuongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::Muon>*)
   {
      ::edm::Ptr<pat::Muon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::Muon>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::Muon>", ::edm::Ptr<pat::Muon>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::Muon>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLMuongR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::Muon>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLMuongR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLMuongR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLMuongR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLMuongR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLMuongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::Muon>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::Muon>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::Muon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLMuongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::Muon>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLMuongR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLMuongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLTaugR_Dictionary();
   static void edmcLcLPtrlEpatcLcLTaugR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLTaugR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLTaugR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLTaugR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLTaugR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::Tau>*)
   {
      ::edm::Ptr<pat::Tau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::Tau>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::Tau>", ::edm::Ptr<pat::Tau>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::Tau>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLTaugR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::Tau>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLTaugR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLTaugR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLTaugR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLTaugR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLTaugR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::Tau>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::Tau>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::Tau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLTaugR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::Tau>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLTaugR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLTaugR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLJetgR_Dictionary();
   static void edmcLcLPtrlEpatcLcLJetgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLJetgR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLJetgR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLJetgR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLJetgR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLJetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::Jet>*)
   {
      ::edm::Ptr<pat::Jet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::Jet>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::Jet>", ::edm::Ptr<pat::Jet>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::Jet>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLJetgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::Jet>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLJetgR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLJetgR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLJetgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLJetgR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLJetgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::Jet>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::Jet>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::Jet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLJetgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::Jet>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLJetgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLJetgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLMETgR_Dictionary();
   static void edmcLcLPtrlEpatcLcLMETgR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLMETgR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLMETgR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLMETgR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLMETgR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLMETgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::MET>*)
   {
      ::edm::Ptr<pat::MET> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::MET>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::MET>", ::edm::Ptr<pat::MET>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::MET>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLMETgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::MET>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLMETgR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLMETgR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLMETgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLMETgR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLMETgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::MET>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::MET>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::MET>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLMETgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::MET>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLMETgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLMETgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLPtrlEpatcLcLConversiongR_Dictionary();
   static void edmcLcLPtrlEpatcLcLConversiongR_TClassManip(TClass*);
   static void *new_edmcLcLPtrlEpatcLcLConversiongR(void *p = 0);
   static void *newArray_edmcLcLPtrlEpatcLcLConversiongR(Long_t size, void *p);
   static void delete_edmcLcLPtrlEpatcLcLConversiongR(void *p);
   static void deleteArray_edmcLcLPtrlEpatcLcLConversiongR(void *p);
   static void destruct_edmcLcLPtrlEpatcLcLConversiongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ptr<pat::Conversion>*)
   {
      ::edm::Ptr<pat::Conversion> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ptr<pat::Conversion>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ptr<pat::Conversion>", ::edm::Ptr<pat::Conversion>::Class_Version(), "DataFormats/Common/interface/Ptr.h", 39,
                  typeid(::edm::Ptr<pat::Conversion>), DefineBehavior(ptr, ptr),
                  &edmcLcLPtrlEpatcLcLConversiongR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ptr<pat::Conversion>) );
      instance.SetNew(&new_edmcLcLPtrlEpatcLcLConversiongR);
      instance.SetNewArray(&newArray_edmcLcLPtrlEpatcLcLConversiongR);
      instance.SetDelete(&delete_edmcLcLPtrlEpatcLcLConversiongR);
      instance.SetDeleteArray(&deleteArray_edmcLcLPtrlEpatcLcLConversiongR);
      instance.SetDestructor(&destruct_edmcLcLPtrlEpatcLcLConversiongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ptr<pat::Conversion>*)
   {
      return GenerateInitInstanceLocal((::edm::Ptr<pat::Conversion>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ptr<pat::Conversion>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLPtrlEpatcLcLConversiongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ptr<pat::Conversion>*)0x0)->GetClass();
      edmcLcLPtrlEpatcLcLConversiongR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLPtrlEpatcLcLConversiongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLFwdPtrlEpatcLcLPackedCandidategR_Dictionary();
   static void edmcLcLFwdPtrlEpatcLcLPackedCandidategR_TClassManip(TClass*);
   static void *new_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p = 0);
   static void *newArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(Long_t size, void *p);
   static void delete_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p);
   static void deleteArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p);
   static void destruct_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FwdPtr<pat::PackedCandidate>*)
   {
      ::edm::FwdPtr<pat::PackedCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FwdPtr<pat::PackedCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("edm::FwdPtr<pat::PackedCandidate>", ::edm::FwdPtr<pat::PackedCandidate>::Class_Version(), "DataFormats/Common/interface/FwdPtr.h", 42,
                  typeid(::edm::FwdPtr<pat::PackedCandidate>), DefineBehavior(ptr, ptr),
                  &edmcLcLFwdPtrlEpatcLcLPackedCandidategR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::FwdPtr<pat::PackedCandidate>) );
      instance.SetNew(&new_edmcLcLFwdPtrlEpatcLcLPackedCandidategR);
      instance.SetNewArray(&newArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR);
      instance.SetDelete(&delete_edmcLcLFwdPtrlEpatcLcLPackedCandidategR);
      instance.SetDeleteArray(&deleteArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR);
      instance.SetDestructor(&destruct_edmcLcLFwdPtrlEpatcLcLPackedCandidategR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FwdPtr<pat::PackedCandidate>*)
   {
      return GenerateInitInstanceLocal((::edm::FwdPtr<pat::PackedCandidate>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FwdPtr<pat::PackedCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLFwdPtrlEpatcLcLPackedCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::FwdPtr<pat::PackedCandidate>*)0x0)->GetClass();
      edmcLcLFwdPtrlEpatcLcLPackedCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLFwdPtrlEpatcLcLPackedCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)
   {
      ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >", ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)
   {
      ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >", ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >","edm::Wrapper<std::vector<edm::FwdPtr<pat::PackedCandidate> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >","vector<pat::Electron>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >","vector<pat::Muon>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >","vector<pat::Tau>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >","vector<pat::Photon>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >","vector<pat::Jet>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >","vector<pat::MET>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >","vector<pat::MHT>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >","vector<pat::Particle>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >","vector<pat::CompositeCandidate>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >","vector<pat::PFParticle>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >","vector<pat::GenericParticle>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >","vector<pat::Hemisphere>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >","vector<pat::Conversion>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >","vector<pat::PackedCandidate>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)
   {
      ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >", "string", 709,
                  typeid(::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >) );
      instance.SetNew(&new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >","vector<pat::PackedGenParticle>::const_iterator");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *__gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)0x0)->GetClass();
      __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void __gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Electron> >*)
   {
      ::edm::Wrapper<vector<pat::Electron> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Electron> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Electron> >", ::edm::Wrapper<vector<pat::Electron> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Electron> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Electron> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Electron> >","edm::Wrapper<std::vector<pat::Electron> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Electron> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Electron> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Electron> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Electron> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Muon> >*)
   {
      ::edm::Wrapper<vector<pat::Muon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Muon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Muon> >", ::edm::Wrapper<vector<pat::Muon> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Muon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Muon> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Muon> >","edm::Wrapper<std::vector<pat::Muon> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Muon> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Muon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Muon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Muon> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Tau> >*)
   {
      ::edm::Wrapper<vector<pat::Tau> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Tau> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Tau> >", ::edm::Wrapper<vector<pat::Tau> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Tau> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Tau> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Tau> >","edm::Wrapper<std::vector<pat::Tau> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Tau> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Tau> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Tau> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Tau> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Photon> >*)
   {
      ::edm::Wrapper<vector<pat::Photon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Photon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Photon> >", ::edm::Wrapper<vector<pat::Photon> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Photon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Photon> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Photon> >","edm::Wrapper<std::vector<pat::Photon> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Photon> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Photon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Photon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Photon> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Jet> >*)
   {
      ::edm::Wrapper<vector<pat::Jet> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Jet> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Jet> >", ::edm::Wrapper<vector<pat::Jet> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Jet> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Jet> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Jet> >","edm::Wrapper<std::vector<pat::Jet> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Jet> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Jet> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Jet> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Jet> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::MET> >*)
   {
      ::edm::Wrapper<vector<pat::MET> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::MET> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::MET> >", ::edm::Wrapper<vector<pat::MET> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::MET> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::MET> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::MET> >","edm::Wrapper<std::vector<pat::MET> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::MET> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::MET> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::MET> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::MET> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::MHT> >*)
   {
      ::edm::Wrapper<vector<pat::MHT> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::MHT> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::MHT> >", ::edm::Wrapper<vector<pat::MHT> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::MHT> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::MHT> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::MHT> >","edm::Wrapper<std::vector<pat::MHT> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::MHT> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::MHT> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::MHT> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::MHT> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Particle> >*)
   {
      ::edm::Wrapper<vector<pat::Particle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Particle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Particle> >", ::edm::Wrapper<vector<pat::Particle> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Particle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Particle> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Particle> >","edm::Wrapper<std::vector<pat::Particle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Particle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Particle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Particle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Particle> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::CompositeCandidate> >*)
   {
      ::edm::Wrapper<vector<pat::CompositeCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::CompositeCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::CompositeCandidate> >", ::edm::Wrapper<vector<pat::CompositeCandidate> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::CompositeCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::CompositeCandidate> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::CompositeCandidate> >","edm::Wrapper<std::vector<pat::CompositeCandidate> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::CompositeCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::CompositeCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::CompositeCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::CompositeCandidate> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::PFParticle> >*)
   {
      ::edm::Wrapper<vector<pat::PFParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::PFParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::PFParticle> >", ::edm::Wrapper<vector<pat::PFParticle> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::PFParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::PFParticle> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::PFParticle> >","edm::Wrapper<std::vector<pat::PFParticle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::PFParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::PFParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PFParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PFParticle> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::GenericParticle> >*)
   {
      ::edm::Wrapper<vector<pat::GenericParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::GenericParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::GenericParticle> >", ::edm::Wrapper<vector<pat::GenericParticle> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::GenericParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::GenericParticle> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::GenericParticle> >","edm::Wrapper<std::vector<pat::GenericParticle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::GenericParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::GenericParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::GenericParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::GenericParticle> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Hemisphere> >*)
   {
      ::edm::Wrapper<vector<pat::Hemisphere> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Hemisphere> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Hemisphere> >", ::edm::Wrapper<vector<pat::Hemisphere> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Hemisphere> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Hemisphere> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Hemisphere> >","edm::Wrapper<std::vector<pat::Hemisphere> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Hemisphere> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Hemisphere> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Hemisphere> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Hemisphere> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::Conversion> >*)
   {
      ::edm::Wrapper<vector<pat::Conversion> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::Conversion> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::Conversion> >", ::edm::Wrapper<vector<pat::Conversion> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::Conversion> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::Conversion> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::Conversion> >","edm::Wrapper<std::vector<pat::Conversion> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::Conversion> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::Conversion> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Conversion> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::Conversion> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::PackedCandidate> >*)
   {
      ::edm::Wrapper<vector<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::PackedCandidate> >", ::edm::Wrapper<vector<pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::PackedCandidate> >","edm::Wrapper<std::vector<pat::PackedCandidate> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<pat::PackedGenParticle> >*)
   {
      ::edm::Wrapper<vector<pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<pat::PackedGenParticle> >", ::edm::Wrapper<vector<pat::PackedGenParticle> >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<pat::PackedGenParticle> >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<pat::PackedGenParticle> >","edm::Wrapper<std::vector<pat::PackedGenParticle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<pat::PackedGenParticle> >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)
   {
      ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >", ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >","pat::ElectronRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)
   {
      ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >", ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >","pat::MuonRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)
   {
      ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >", ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >","pat::TauRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)
   {
      ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >", ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >","pat::PhotonRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)
   {
      ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >", ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >","pat::JetRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)
   {
      ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >", ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >","pat::METRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)
   {
      ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >", ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >","pat::ParticleRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)
   {
      ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >", ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >","pat::CompositeCandidateRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)
   {
      ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >", ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >","pat::PFParticleRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)
   {
      ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >", ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >","pat::GenericParticleRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)
   {
      ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >", ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >","pat::HemisphereRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)
   {
      ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >", ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >","pat::ConversionRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)
   {
      ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >", ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >","pat::PackedCandidateRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)
   {
      ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >", ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::Class_Version(), "DataFormats/Common/interface/Ref.h", 307,
                  typeid(::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >) );
      instance.SetNew(&new_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >","pat::PackedGenParticleRef");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0x0)->GetClass();
      edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)
   {
      ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >", ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >","pat::ElectronRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)
   {
      ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >", ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >","pat::MuonRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)
   {
      ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >", ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >","pat::TauRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)
   {
      ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >", ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >","pat::PhotonRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)
   {
      ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >", ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >","pat::JetRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)
   {
      ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >", ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >","pat::METRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)
   {
      ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >", ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >","pat::ParticleRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)
   {
      ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >", ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >","pat::CompositeCandidateRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)
   {
      ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >", ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >","pat::PFParticleRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)
   {
      ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >", ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >","pat::GenericParticleRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)
   {
      ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >", ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >","pat::HemisphereRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)
   {
      ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >", ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >","pat::ConversionRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)
   {
      ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >", ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >","pat::PackedCandidateRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)
   {
      ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >", ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >::Class_Version(), "DataFormats/Common/interface/RefVector.h", 35,
                  typeid(::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >) );
      instance.SetNew(&new_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >","pat::PackedGenParticleRefVector");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)0x0)->GetClass();
      edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >","edm::Wrapper<pat::ElectronRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >","edm::Wrapper<pat::MuonRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >","edm::Wrapper<pat::TauRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >","edm::Wrapper<pat::PhotonRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >","edm::Wrapper<pat::JetRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >","edm::Wrapper<pat::METRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >","edm::Wrapper<pat::ParticleRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >","edm::Wrapper<pat::CompositeCandidateRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >","edm::Wrapper<pat::PFParticleRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >","edm::Wrapper<pat::GenericParticleRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >","edm::Wrapper<pat::HemisphereRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)
   {
      ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >", ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >","edm::Wrapper<pat::ConversionRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >","edm::reftobase::Holder<reco::Candidate,pat::ElectronRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >","edm::reftobase::Holder<reco::Candidate,pat::MuonRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >","edm::reftobase::Holder<reco::Candidate,pat::TauRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >","edm::reftobase::Holder<reco::Candidate,pat::PhotonRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >","edm::reftobase::Holder<reco::Candidate,pat::JetRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >","edm::reftobase::Holder<reco::Candidate,pat::METRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >","edm::reftobase::Holder<reco::Candidate,pat::ParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >","edm::reftobase::Holder<reco::Candidate,pat::CompositeCandidateRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >","edm::reftobase::Holder<reco::Candidate,pat::PFParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >::Class_Version(), "DataFormats/Common/interface/Holder.h", 16,
                  typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >","edm::reftobase::Holder<reco::Candidate,pat::GenericParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >","edm::reftobase::RefHolder<pat::ElectronRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >","edm::reftobase::RefHolder<pat::MuonRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >","edm::reftobase::RefHolder<pat::TauRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >","edm::reftobase::RefHolder<pat::PhotonRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >","edm::reftobase::RefHolder<pat::JetRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >","edm::reftobase::RefHolder<pat::METRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >","edm::reftobase::RefHolder<pat::ParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >","edm::reftobase::RefHolder<pat::CompositeCandidateRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >","edm::reftobase::RefHolder<pat::PFParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >::Class_Version(), "DataFormats/Common/interface/RefHolder_.h", 19,
                  typeid(::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >","edm::reftobase::RefHolder<pat::GenericParticleRef>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version(), "DataFormats/Common/interface/RefVectorHolder.h", 15,
                  typeid(::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >","edm::reftobase::RefVectorHolder<pat::CompositeCandidateRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >::Class_Version(), "DataFormats/Common/interface/VectorHolder.h", 15,
                  typeid(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >) );
      instance.SetNew(&new_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >","edm::reftobase::VectorHolder<reco::Candidate,pat::CompositeCandidateRefVector>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)0x0)->GetClass();
      edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefProd<vector<pat::PackedCandidate> >*)
   {
      ::edm::RefProd<vector<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefProd<vector<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefProd<vector<pat::PackedCandidate> >", ::edm::RefProd<vector<pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/RefProd.h", 50,
                  typeid(::edm::RefProd<vector<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefProd<vector<pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("edm::RefProd<vector<pat::PackedCandidate> >","edm::RefProd<pat::PackedCandidateCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefProd<vector<pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefProd<vector<pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefProd<vector<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefProd<vector<pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Association<vector<pat::PackedCandidate> >*)
   {
      ::edm::Association<vector<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Association<vector<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Association<vector<pat::PackedCandidate> >", ::edm::Association<vector<pat::PackedCandidate> >::Class_Version(), "DataFormats/Common/interface/Association.h", 18,
                  typeid(::edm::Association<vector<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Association<vector<pat::PackedCandidate> >) );
      instance.SetNew(&new_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR);

      ROOT::AddClassAlternate("edm::Association<vector<pat::PackedCandidate> >","edm::Association<pat::PackedCandidateCollection>");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Association<vector<pat::PackedCandidate> >*)
   {
      return GenerateInitInstanceLocal((::edm::Association<vector<pat::PackedCandidate> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Association<vector<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Association<vector<pat::PackedCandidate> >*)0x0)->GetClass();
      edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)
   {
      ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >", ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >","edm::Wrapper<edm::Association<pat::PackedCandidateCollection> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RefProd<vector<pat::PackedGenParticle> >*)
   {
      ::edm::RefProd<vector<pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RefProd<vector<pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::RefProd<vector<pat::PackedGenParticle> >", ::edm::RefProd<vector<pat::PackedGenParticle> >::Class_Version(), "DataFormats/Common/interface/RefProd.h", 50,
                  typeid(::edm::RefProd<vector<pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::RefProd<vector<pat::PackedGenParticle> >) );
      instance.SetNew(&new_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("edm::RefProd<vector<pat::PackedGenParticle> >","edm::RefProd<std::vector<pat::PackedGenParticle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RefProd<vector<pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::RefProd<vector<pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RefProd<vector<pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::RefProd<vector<pat::PackedGenParticle> >*)0x0)->GetClass();
      edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary();
   static void edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p = 0);
   static void *newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t size, void *p);
   static void delete_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);
   static void destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Association<vector<pat::PackedGenParticle> >*)
   {
      ::edm::Association<vector<pat::PackedGenParticle> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Association<vector<pat::PackedGenParticle> >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Association<vector<pat::PackedGenParticle> >", ::edm::Association<vector<pat::PackedGenParticle> >::Class_Version(), "DataFormats/Common/interface/Association.h", 18,
                  typeid(::edm::Association<vector<pat::PackedGenParticle> >), DefineBehavior(ptr, ptr),
                  &edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Association<vector<pat::PackedGenParticle> >) );
      instance.SetNew(&new_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetNewArray(&newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDelete(&delete_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR);
      instance.SetDestructor(&destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR);

      ROOT::AddClassAlternate("edm::Association<vector<pat::PackedGenParticle> >","edm::Association<std::vector<pat::PackedGenParticle> >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Association<vector<pat::PackedGenParticle> >*)
   {
      return GenerateInitInstanceLocal((::edm::Association<vector<pat::PackedGenParticle> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Association<vector<pat::PackedGenParticle> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Association<vector<pat::PackedGenParticle> >*)0x0)->GetClass();
      edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)
   {
      ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >", ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >","edm::Wrapper<edm::Association<std::vector<pat::PackedGenParticle> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)0x0)->GetClass();
      edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)
   {
      ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<edm::Ptr<pat::Jet> > >", ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<edm::Ptr<pat::Jet> > >","edm::Wrapper<std::vector<edm::Ptr<pat::Jet> > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   static TClass *edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_Dictionary();
   static void edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_TClassManip(TClass*);
   static void *new_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)
   {
      ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >));
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >", ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >::Class_Version(), "DataFormats/Common/interface/Wrapper.h", 29,
                  typeid(::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR);

      ROOT::AddClassAlternate("edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >","edm::Wrapper<std::vector<std::vector<edm::Ptr<pat::Jet> > > >");
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)0x0)->GetClass();
      edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::GsfElectron> : new ::pat::PATObject<reco::GsfElectron>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLGsfElectrongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::GsfElectron>[nElements] : new ::pat::PATObject<reco::GsfElectron>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p) {
      delete ((::pat::PATObject<reco::GsfElectron>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p) {
      delete [] ((::pat::PATObject<reco::GsfElectron>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLGsfElectrongR(void *p) {
      typedef ::pat::PATObject<reco::GsfElectron> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::GsfElectron>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLMuongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Muon> : new ::pat::PATObject<reco::Muon>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLMuongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Muon>[nElements] : new ::pat::PATObject<reco::Muon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLMuongR(void *p) {
      delete ((::pat::PATObject<reco::Muon>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLMuongR(void *p) {
      delete [] ((::pat::PATObject<reco::Muon>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLMuongR(void *p) {
      typedef ::pat::PATObject<reco::Muon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::Muon>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLBaseTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::BaseTau> : new ::pat::PATObject<reco::BaseTau>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLBaseTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::BaseTau>[nElements] : new ::pat::PATObject<reco::BaseTau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLBaseTaugR(void *p) {
      delete ((::pat::PATObject<reco::BaseTau>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLBaseTaugR(void *p) {
      delete [] ((::pat::PATObject<reco::BaseTau>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLBaseTaugR(void *p) {
      typedef ::pat::PATObject<reco::BaseTau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::BaseTau>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLPhotongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Photon> : new ::pat::PATObject<reco::Photon>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLPhotongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Photon>[nElements] : new ::pat::PATObject<reco::Photon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLPhotongR(void *p) {
      delete ((::pat::PATObject<reco::Photon>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLPhotongR(void *p) {
      delete [] ((::pat::PATObject<reco::Photon>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLPhotongR(void *p) {
      typedef ::pat::PATObject<reco::Photon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::Photon>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLJetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Jet> : new ::pat::PATObject<reco::Jet>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLJetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::Jet>[nElements] : new ::pat::PATObject<reco::Jet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLJetgR(void *p) {
      delete ((::pat::PATObject<reco::Jet>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLJetgR(void *p) {
      delete [] ((::pat::PATObject<reco::Jet>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLJetgR(void *p) {
      typedef ::pat::PATObject<reco::Jet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::Jet>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLMETgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::MET> : new ::pat::PATObject<reco::MET>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLMETgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::MET>[nElements] : new ::pat::PATObject<reco::MET>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLMETgR(void *p) {
      delete ((::pat::PATObject<reco::MET>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLMETgR(void *p) {
      delete [] ((::pat::PATObject<reco::MET>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLMETgR(void *p) {
      typedef ::pat::PATObject<reco::MET> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::MET>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::LeafCandidate> : new ::pat::PATObject<reco::LeafCandidate>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLLeafCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::LeafCandidate>[nElements] : new ::pat::PATObject<reco::LeafCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p) {
      delete ((::pat::PATObject<reco::LeafCandidate>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p) {
      delete [] ((::pat::PATObject<reco::LeafCandidate>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLLeafCandidategR(void *p) {
      typedef ::pat::PATObject<reco::LeafCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::LeafCandidate>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::CompositeCandidate> : new ::pat::PATObject<reco::CompositeCandidate>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLCompositeCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::CompositeCandidate>[nElements] : new ::pat::PATObject<reco::CompositeCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p) {
      delete ((::pat::PATObject<reco::CompositeCandidate>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p) {
      delete [] ((::pat::PATObject<reco::CompositeCandidate>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLCompositeCandidategR(void *p) {
      typedef ::pat::PATObject<reco::CompositeCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::CompositeCandidate>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPATObjectlErecocLcLPFCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::PFCandidate> : new ::pat::PATObject<reco::PFCandidate>;
   }
   static void *newArray_patcLcLPATObjectlErecocLcLPFCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PATObject<reco::PFCandidate>[nElements] : new ::pat::PATObject<reco::PFCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLPFCandidategR(void *p) {
      delete ((::pat::PATObject<reco::PFCandidate>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLPFCandidategR(void *p) {
      delete [] ((::pat::PATObject<reco::PFCandidate>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLPFCandidategR(void *p) {
      typedef ::pat::PATObject<reco::PFCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::PFCandidate>

namespace ROOT {
   // Wrapper around operator delete
   static void delete_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p) {
      delete ((::pat::PATObject<reco::RecoCandidate>*)p);
   }
   static void deleteArray_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p) {
      delete [] ((::pat::PATObject<reco::RecoCandidate>*)p);
   }
   static void destruct_patcLcLPATObjectlErecocLcLRecoCandidategR(void *p) {
      typedef ::pat::PATObject<reco::RecoCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PATObject<reco::RecoCandidate>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLLeptonlErecocLcLGsfElectrongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::GsfElectron> : new ::pat::Lepton<reco::GsfElectron>;
   }
   static void *newArray_patcLcLLeptonlErecocLcLGsfElectrongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::GsfElectron>[nElements] : new ::pat::Lepton<reco::GsfElectron>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLLeptonlErecocLcLGsfElectrongR(void *p) {
      delete ((::pat::Lepton<reco::GsfElectron>*)p);
   }
   static void deleteArray_patcLcLLeptonlErecocLcLGsfElectrongR(void *p) {
      delete [] ((::pat::Lepton<reco::GsfElectron>*)p);
   }
   static void destruct_patcLcLLeptonlErecocLcLGsfElectrongR(void *p) {
      typedef ::pat::Lepton<reco::GsfElectron> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Lepton<reco::GsfElectron>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLLeptonlErecocLcLMuongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::Muon> : new ::pat::Lepton<reco::Muon>;
   }
   static void *newArray_patcLcLLeptonlErecocLcLMuongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::Muon>[nElements] : new ::pat::Lepton<reco::Muon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLLeptonlErecocLcLMuongR(void *p) {
      delete ((::pat::Lepton<reco::Muon>*)p);
   }
   static void deleteArray_patcLcLLeptonlErecocLcLMuongR(void *p) {
      delete [] ((::pat::Lepton<reco::Muon>*)p);
   }
   static void destruct_patcLcLLeptonlErecocLcLMuongR(void *p) {
      typedef ::pat::Lepton<reco::Muon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Lepton<reco::Muon>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLLeptonlErecocLcLBaseTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::BaseTau> : new ::pat::Lepton<reco::BaseTau>;
   }
   static void *newArray_patcLcLLeptonlErecocLcLBaseTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Lepton<reco::BaseTau>[nElements] : new ::pat::Lepton<reco::BaseTau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLLeptonlErecocLcLBaseTaugR(void *p) {
      delete ((::pat::Lepton<reco::BaseTau>*)p);
   }
   static void deleteArray_patcLcLLeptonlErecocLcLBaseTaugR(void *p) {
      delete [] ((::pat::Lepton<reco::BaseTau>*)p);
   }
   static void destruct_patcLcLLeptonlErecocLcLBaseTaugR(void *p) {
      typedef ::pat::Lepton<reco::BaseTau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Lepton<reco::BaseTau>

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLElectron(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Electron : new ::pat::Electron;
   }
   static void *newArray_patcLcLElectron(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Electron[nElements] : new ::pat::Electron[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLElectron(void *p) {
      delete ((::pat::Electron*)p);
   }
   static void deleteArray_patcLcLElectron(void *p) {
      delete [] ((::pat::Electron*)p);
   }
   static void destruct_patcLcLElectron(void *p) {
      typedef ::pat::Electron current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Electron

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<vector<reco::SuperCluster> > : new ::edm::AtomicPtrCache<vector<reco::SuperCluster> >;
   }
   static void *newArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<vector<reco::SuperCluster> >[nElements] : new ::edm::AtomicPtrCache<vector<reco::SuperCluster> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p) {
      delete ((::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)p);
   }
   static void deleteArray_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p) {
      delete [] ((::edm::AtomicPtrCache<vector<reco::SuperCluster> >*)p);
   }
   static void destruct_edmcLcLAtomicPtrCachelEvectorlErecocLcLSuperClustergRsPgR(void *p) {
      typedef ::edm::AtomicPtrCache<vector<reco::SuperCluster> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::AtomicPtrCache<vector<reco::SuperCluster> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLMuon(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Muon : new ::pat::Muon;
   }
   static void *newArray_patcLcLMuon(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Muon[nElements] : new ::pat::Muon[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLMuon(void *p) {
      delete ((::pat::Muon*)p);
   }
   static void deleteArray_patcLcLMuon(void *p) {
      delete [] ((::pat::Muon*)p);
   }
   static void destruct_patcLcLMuon(void *p) {
      typedef ::pat::Muon current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Muon

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLTau(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Tau : new ::pat::Tau;
   }
   static void *newArray_patcLcLTau(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Tau[nElements] : new ::pat::Tau[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLTau(void *p) {
      delete ((::pat::Tau*)p);
   }
   static void deleteArray_patcLcLTau(void *p) {
      delete [] ((::pat::Tau*)p);
   }
   static void destruct_patcLcLTau(void *p) {
      typedef ::pat::Tau current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Tau

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > > : new ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >;
   }
   static void *newArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >[nElements] : new ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p) {
      delete ((::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)p);
   }
   static void deleteArray_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p) {
      delete [] ((::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >*)p);
   }
   static void destruct_edmcLcLAtomicPtrCachelEedmcLcLRefVectorlEvectorlErecocLcLTrackgRcOrecocLcLTrackcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlErecocLcLTrackgRcOrecocLcLTrackgRsPgRsPgR(void *p) {
      typedef ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > > : new ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >;
   }
   static void *newArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >[nElements] : new ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p) {
      delete ((::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >*)p);
   }
   static void destruct_edmcLcLAtomicPtrCachelEvectorlEedmcLcLPtrlErecocLcLPFCandidategRsPgRsPgR(void *p) {
      typedef ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLtaucLcLTauPFSpecific(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauPFSpecific : new ::pat::tau::TauPFSpecific;
   }
   static void *newArray_patcLcLtaucLcLTauPFSpecific(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauPFSpecific[nElements] : new ::pat::tau::TauPFSpecific[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLtaucLcLTauPFSpecific(void *p) {
      delete ((::pat::tau::TauPFSpecific*)p);
   }
   static void deleteArray_patcLcLtaucLcLTauPFSpecific(void *p) {
      delete [] ((::pat::tau::TauPFSpecific*)p);
   }
   static void destruct_patcLcLtaucLcLTauPFSpecific(void *p) {
      typedef ::pat::tau::TauPFSpecific current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::tau::TauPFSpecific

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLtaucLcLTauCaloSpecific(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauCaloSpecific : new ::pat::tau::TauCaloSpecific;
   }
   static void *newArray_patcLcLtaucLcLTauCaloSpecific(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauCaloSpecific[nElements] : new ::pat::tau::TauCaloSpecific[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLtaucLcLTauCaloSpecific(void *p) {
      delete ((::pat::tau::TauCaloSpecific*)p);
   }
   static void deleteArray_patcLcLtaucLcLTauCaloSpecific(void *p) {
      delete [] ((::pat::tau::TauCaloSpecific*)p);
   }
   static void destruct_patcLcLtaucLcLTauCaloSpecific(void *p) {
      typedef ::pat::tau::TauCaloSpecific current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::tau::TauCaloSpecific

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLtaucLcLTauPFEssential(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauPFEssential : new ::pat::tau::TauPFEssential;
   }
   static void *newArray_patcLcLtaucLcLTauPFEssential(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::tau::TauPFEssential[nElements] : new ::pat::tau::TauPFEssential[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLtaucLcLTauPFEssential(void *p) {
      delete ((::pat::tau::TauPFEssential*)p);
   }
   static void deleteArray_patcLcLtaucLcLTauPFEssential(void *p) {
      delete [] ((::pat::tau::TauPFEssential*)p);
   }
   static void destruct_patcLcLtaucLcLTauPFEssential(void *p) {
      typedef ::pat::tau::TauPFEssential current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::tau::TauPFEssential

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPhoton(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Photon : new ::pat::Photon;
   }
   static void *newArray_patcLcLPhoton(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Photon[nElements] : new ::pat::Photon[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPhoton(void *p) {
      delete ((::pat::Photon*)p);
   }
   static void deleteArray_patcLcLPhoton(void *p) {
      delete [] ((::pat::Photon*)p);
   }
   static void destruct_patcLcLPhoton(void *p) {
      typedef ::pat::Photon current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Photon

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLJet(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Jet : new ::pat::Jet;
   }
   static void *newArray_patcLcLJet(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Jet[nElements] : new ::pat::Jet[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLJet(void *p) {
      delete ((::pat::Jet*)p);
   }
   static void deleteArray_patcLcLJet(void *p) {
      delete [] ((::pat::Jet*)p);
   }
   static void destruct_patcLcLJet(void *p) {
      typedef ::pat::Jet current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Jet

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLMET(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET : new ::pat::MET;
   }
   static void *newArray_patcLcLMET(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET[nElements] : new ::pat::MET[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLMET(void *p) {
      delete ((::pat::MET*)p);
   }
   static void deleteArray_patcLcLMET(void *p) {
      delete [] ((::pat::MET*)p);
   }
   static void destruct_patcLcLMET(void *p) {
      typedef ::pat::MET current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::MET

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLMETcLcLPackedMETUncertainty(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET::PackedMETUncertainty : new ::pat::MET::PackedMETUncertainty;
   }
   static void *newArray_patcLcLMETcLcLPackedMETUncertainty(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET::PackedMETUncertainty[nElements] : new ::pat::MET::PackedMETUncertainty[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLMETcLcLPackedMETUncertainty(void *p) {
      delete ((::pat::MET::PackedMETUncertainty*)p);
   }
   static void deleteArray_patcLcLMETcLcLPackedMETUncertainty(void *p) {
      delete [] ((::pat::MET::PackedMETUncertainty*)p);
   }
   static void destruct_patcLcLMETcLcLPackedMETUncertainty(void *p) {
      typedef ::pat::MET::PackedMETUncertainty current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::MET::PackedMETUncertainty

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLMETcLcLVector2(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET::Vector2 : new ::pat::MET::Vector2;
   }
   static void *newArray_patcLcLMETcLcLVector2(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MET::Vector2[nElements] : new ::pat::MET::Vector2[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLMETcLcLVector2(void *p) {
      delete ((::pat::MET::Vector2*)p);
   }
   static void deleteArray_patcLcLMETcLcLVector2(void *p) {
      delete [] ((::pat::MET::Vector2*)p);
   }
   static void destruct_patcLcLMETcLcLVector2(void *p) {
      typedef ::pat::MET::Vector2 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::MET::Vector2

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLMHT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MHT : new ::pat::MHT;
   }
   static void *newArray_patcLcLMHT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::MHT[nElements] : new ::pat::MHT[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLMHT(void *p) {
      delete ((::pat::MHT*)p);
   }
   static void deleteArray_patcLcLMHT(void *p) {
      delete [] ((::pat::MHT*)p);
   }
   static void destruct_patcLcLMHT(void *p) {
      typedef ::pat::MHT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::MHT

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLParticle(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Particle : new ::pat::Particle;
   }
   static void *newArray_patcLcLParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Particle[nElements] : new ::pat::Particle[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLParticle(void *p) {
      delete ((::pat::Particle*)p);
   }
   static void deleteArray_patcLcLParticle(void *p) {
      delete [] ((::pat::Particle*)p);
   }
   static void destruct_patcLcLParticle(void *p) {
      typedef ::pat::Particle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Particle

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLCompositeCandidate(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::CompositeCandidate : new ::pat::CompositeCandidate;
   }
   static void *newArray_patcLcLCompositeCandidate(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::CompositeCandidate[nElements] : new ::pat::CompositeCandidate[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLCompositeCandidate(void *p) {
      delete ((::pat::CompositeCandidate*)p);
   }
   static void deleteArray_patcLcLCompositeCandidate(void *p) {
      delete [] ((::pat::CompositeCandidate*)p);
   }
   static void destruct_patcLcLCompositeCandidate(void *p) {
      typedef ::pat::CompositeCandidate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::CompositeCandidate

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPFParticle(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PFParticle : new ::pat::PFParticle;
   }
   static void *newArray_patcLcLPFParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PFParticle[nElements] : new ::pat::PFParticle[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPFParticle(void *p) {
      delete ((::pat::PFParticle*)p);
   }
   static void deleteArray_patcLcLPFParticle(void *p) {
      delete [] ((::pat::PFParticle*)p);
   }
   static void destruct_patcLcLPFParticle(void *p) {
      typedef ::pat::PFParticle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PFParticle

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLGenericParticle(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::GenericParticle : new ::pat::GenericParticle;
   }
   static void *newArray_patcLcLGenericParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::GenericParticle[nElements] : new ::pat::GenericParticle[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLGenericParticle(void *p) {
      delete ((::pat::GenericParticle*)p);
   }
   static void deleteArray_patcLcLGenericParticle(void *p) {
      delete [] ((::pat::GenericParticle*)p);
   }
   static void destruct_patcLcLGenericParticle(void *p) {
      typedef ::pat::GenericParticle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::GenericParticle

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLHemisphere(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Hemisphere : new ::pat::Hemisphere;
   }
   static void *newArray_patcLcLHemisphere(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Hemisphere[nElements] : new ::pat::Hemisphere[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLHemisphere(void *p) {
      delete ((::pat::Hemisphere*)p);
   }
   static void deleteArray_patcLcLHemisphere(void *p) {
      delete [] ((::pat::Hemisphere*)p);
   }
   static void destruct_patcLcLHemisphere(void *p) {
      typedef ::pat::Hemisphere current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Hemisphere

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLConversion(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Conversion : new ::pat::Conversion;
   }
   static void *newArray_patcLcLConversion(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::Conversion[nElements] : new ::pat::Conversion[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLConversion(void *p) {
      delete ((::pat::Conversion*)p);
   }
   static void deleteArray_patcLcLConversion(void *p) {
      delete [] ((::pat::Conversion*)p);
   }
   static void destruct_patcLcLConversion(void *p) {
      typedef ::pat::Conversion current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::Conversion

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPackedCandidate(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PackedCandidate : new ::pat::PackedCandidate;
   }
   static void *newArray_patcLcLPackedCandidate(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PackedCandidate[nElements] : new ::pat::PackedCandidate[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPackedCandidate(void *p) {
      delete ((::pat::PackedCandidate*)p);
   }
   static void deleteArray_patcLcLPackedCandidate(void *p) {
      delete [] ((::pat::PackedCandidate*)p);
   }
   static void destruct_patcLcLPackedCandidate(void *p) {
      typedef ::pat::PackedCandidate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PackedCandidate

namespace ROOT {
   // Wrappers around operator new
   static void *new_patcLcLPackedGenParticle(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PackedGenParticle : new ::pat::PackedGenParticle;
   }
   static void *newArray_patcLcLPackedGenParticle(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::pat::PackedGenParticle[nElements] : new ::pat::PackedGenParticle[nElements];
   }
   // Wrapper around operator delete
   static void delete_patcLcLPackedGenParticle(void *p) {
      delete ((::pat::PackedGenParticle*)p);
   }
   static void deleteArray_patcLcLPackedGenParticle(void *p) {
      delete [] ((::pat::PackedGenParticle*)p);
   }
   static void destruct_patcLcLPackedGenParticle(void *p) {
      typedef ::pat::PackedGenParticle current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::pat::PackedGenParticle

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLElectrongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Electron> : new ::edm::Ptr<pat::Electron>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLElectrongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Electron>[nElements] : new ::edm::Ptr<pat::Electron>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLElectrongR(void *p) {
      delete ((::edm::Ptr<pat::Electron>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLElectrongR(void *p) {
      delete [] ((::edm::Ptr<pat::Electron>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLElectrongR(void *p) {
      typedef ::edm::Ptr<pat::Electron> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::Electron>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLMuongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Muon> : new ::edm::Ptr<pat::Muon>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLMuongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Muon>[nElements] : new ::edm::Ptr<pat::Muon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLMuongR(void *p) {
      delete ((::edm::Ptr<pat::Muon>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLMuongR(void *p) {
      delete [] ((::edm::Ptr<pat::Muon>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLMuongR(void *p) {
      typedef ::edm::Ptr<pat::Muon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::Muon>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Tau> : new ::edm::Ptr<pat::Tau>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Tau>[nElements] : new ::edm::Ptr<pat::Tau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLTaugR(void *p) {
      delete ((::edm::Ptr<pat::Tau>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLTaugR(void *p) {
      delete [] ((::edm::Ptr<pat::Tau>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLTaugR(void *p) {
      typedef ::edm::Ptr<pat::Tau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::Tau>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLJetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Jet> : new ::edm::Ptr<pat::Jet>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLJetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Jet>[nElements] : new ::edm::Ptr<pat::Jet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLJetgR(void *p) {
      delete ((::edm::Ptr<pat::Jet>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLJetgR(void *p) {
      delete [] ((::edm::Ptr<pat::Jet>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLJetgR(void *p) {
      typedef ::edm::Ptr<pat::Jet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::Jet>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLMETgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::MET> : new ::edm::Ptr<pat::MET>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLMETgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::MET>[nElements] : new ::edm::Ptr<pat::MET>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLMETgR(void *p) {
      delete ((::edm::Ptr<pat::MET>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLMETgR(void *p) {
      delete [] ((::edm::Ptr<pat::MET>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLMETgR(void *p) {
      typedef ::edm::Ptr<pat::MET> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::MET>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLPtrlEpatcLcLConversiongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Conversion> : new ::edm::Ptr<pat::Conversion>;
   }
   static void *newArray_edmcLcLPtrlEpatcLcLConversiongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ptr<pat::Conversion>[nElements] : new ::edm::Ptr<pat::Conversion>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLPtrlEpatcLcLConversiongR(void *p) {
      delete ((::edm::Ptr<pat::Conversion>*)p);
   }
   static void deleteArray_edmcLcLPtrlEpatcLcLConversiongR(void *p) {
      delete [] ((::edm::Ptr<pat::Conversion>*)p);
   }
   static void destruct_edmcLcLPtrlEpatcLcLConversiongR(void *p) {
      typedef ::edm::Ptr<pat::Conversion> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ptr<pat::Conversion>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FwdPtr<pat::PackedCandidate> : new ::edm::FwdPtr<pat::PackedCandidate>;
   }
   static void *newArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FwdPtr<pat::PackedCandidate>[nElements] : new ::edm::FwdPtr<pat::PackedCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p) {
      delete ((::edm::FwdPtr<pat::PackedCandidate>*)p);
   }
   static void deleteArray_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p) {
      delete [] ((::edm::FwdPtr<pat::PackedCandidate>*)p);
   }
   static void destruct_edmcLcLFwdPtrlEpatcLcLPackedCandidategR(void *p) {
      typedef ::edm::FwdPtr<pat::PackedCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FwdPtr<pat::PackedCandidate>

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> > : new ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >[nElements] : new ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > > : new ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >[nElements] : new ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> > : new ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLElectronmUcOvectorlEpatcLcLElectrongRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> > : new ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMuonmUcOvectorlEpatcLcLMuongRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> > : new ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLTaumUcOvectorlEpatcLcLTaugRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> > : new ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPhotonmUcOvectorlEpatcLcLPhotongRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> > : new ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLJetmUcOvectorlEpatcLcLJetgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> > : new ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMETmUcOvectorlEpatcLcLMETgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> > : new ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLMHTmUcOvectorlEpatcLcLMHTgRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> > : new ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLParticlemUcOvectorlEpatcLcLParticlegRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> > : new ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLCompositeCandidatemUcOvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> > : new ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPFParticlemUcOvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> > : new ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLGenericParticlemUcOvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> > : new ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLHemispheremUcOvectorlEpatcLcLHemispheregRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> > : new ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLConversionmUcOvectorlEpatcLcLConversiongRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> > : new ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedCandidatemUcOvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> > : new ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >;
   }
   static void *newArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >[nElements] : new ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)p);
   }
   static void deleteArray___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >*)p);
   }
   static void destruct___gnu_cxxcLcL__normal_iteratorlEconstsPpatcLcLPackedGenParticlemUcOvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Electron> > : new ::edm::Wrapper<vector<pat::Electron> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Electron> >[nElements] : new ::edm::Wrapper<vector<pat::Electron> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Electron> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Electron> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLElectrongRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Electron> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Electron> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Muon> > : new ::edm::Wrapper<vector<pat::Muon> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Muon> >[nElements] : new ::edm::Wrapper<vector<pat::Muon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Muon> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Muon> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMuongRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Muon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Muon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Tau> > : new ::edm::Wrapper<vector<pat::Tau> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Tau> >[nElements] : new ::edm::Wrapper<vector<pat::Tau> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Tau> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Tau> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLTaugRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Tau> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Tau> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Photon> > : new ::edm::Wrapper<vector<pat::Photon> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Photon> >[nElements] : new ::edm::Wrapper<vector<pat::Photon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Photon> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Photon> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPhotongRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Photon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Photon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Jet> > : new ::edm::Wrapper<vector<pat::Jet> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Jet> >[nElements] : new ::edm::Wrapper<vector<pat::Jet> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Jet> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Jet> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLJetgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Jet> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Jet> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::MET> > : new ::edm::Wrapper<vector<pat::MET> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::MET> >[nElements] : new ::edm::Wrapper<vector<pat::MET> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::MET> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::MET> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMETgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::MET> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::MET> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::MHT> > : new ::edm::Wrapper<vector<pat::MHT> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::MHT> >[nElements] : new ::edm::Wrapper<vector<pat::MHT> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::MHT> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::MHT> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLMHTgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::MHT> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::MHT> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Particle> > : new ::edm::Wrapper<vector<pat::Particle> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Particle> >[nElements] : new ::edm::Wrapper<vector<pat::Particle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Particle> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Particle> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLParticlegRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Particle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Particle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::CompositeCandidate> > : new ::edm::Wrapper<vector<pat::CompositeCandidate> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::CompositeCandidate> >[nElements] : new ::edm::Wrapper<vector<pat::CompositeCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::CompositeCandidate> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::CompositeCandidate> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLCompositeCandidategRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::CompositeCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::CompositeCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PFParticle> > : new ::edm::Wrapper<vector<pat::PFParticle> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PFParticle> >[nElements] : new ::edm::Wrapper<vector<pat::PFParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::PFParticle> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::PFParticle> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPFParticlegRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::PFParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::PFParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::GenericParticle> > : new ::edm::Wrapper<vector<pat::GenericParticle> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::GenericParticle> >[nElements] : new ::edm::Wrapper<vector<pat::GenericParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::GenericParticle> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::GenericParticle> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLGenericParticlegRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::GenericParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::GenericParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Hemisphere> > : new ::edm::Wrapper<vector<pat::Hemisphere> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Hemisphere> >[nElements] : new ::edm::Wrapper<vector<pat::Hemisphere> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Hemisphere> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Hemisphere> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLHemispheregRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Hemisphere> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Hemisphere> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Conversion> > : new ::edm::Wrapper<vector<pat::Conversion> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::Conversion> >[nElements] : new ::edm::Wrapper<vector<pat::Conversion> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::Conversion> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::Conversion> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLConversiongRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::Conversion> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::Conversion> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PackedCandidate> > : new ::edm::Wrapper<vector<pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PackedCandidate> >[nElements] : new ::edm::Wrapper<vector<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PackedGenParticle> > : new ::edm::Wrapper<vector<pat::PackedGenParticle> >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<pat::PackedGenParticle> >[nElements] : new ::edm::Wrapper<vector<pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<pat::PackedGenParticle> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<pat::PackedGenParticle> >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > : new ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >[nElements] : new ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > : new ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >[nElements] : new ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > : new ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >[nElements] : new ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > : new ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >[nElements] : new ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > : new ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >[nElements] : new ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > : new ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >[nElements] : new ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > : new ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >[nElements] : new ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > : new ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >[nElements] : new ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > : new ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >[nElements] : new ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > : new ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >[nElements] : new ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > : new ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >[nElements] : new ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > : new ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >[nElements] : new ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > : new ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >[nElements] : new ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > : new ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >;
   }
   static void *newArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >[nElements] : new ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)p);
   }
   static void deleteArray_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)p);
   }
   static void destruct_edmcLcLReflEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > : new ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >[nElements] : new ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > : new ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >[nElements] : new ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > : new ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >[nElements] : new ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > : new ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >[nElements] : new ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > : new ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >[nElements] : new ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > : new ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >[nElements] : new ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > : new ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >[nElements] : new ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > : new ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >[nElements] : new ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > : new ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >[nElements] : new ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > : new ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >[nElements] : new ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > : new ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >[nElements] : new ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > : new ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >[nElements] : new ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > : new ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >[nElements] : new ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedCandidategRcOpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > : new ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >;
   }
   static void *newArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >[nElements] : new ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)p);
   }
   static void deleteArray_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >*)p);
   }
   static void destruct_edmcLcLRefVectorlEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPackedGenParticlegRcOpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLHemispheregRcOpatcLcLHemispherecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLHemispheregRcOpatcLcLHemispheregRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > > : new ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >[nElements] : new ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLRefVectorlEvectorlEpatcLcLConversiongRcOpatcLcLConversioncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLConversiongRcOpatcLcLConversiongRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements] : new ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLHolderlErecocLcLCandidatecOedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLElectrongRcOpatcLcLElectroncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLElectrongRcOpatcLcLElectrongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMuongRcOpatcLcLMuoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMuongRcOpatcLcLMuongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLTaugRcOpatcLcLTaucOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLTaugRcOpatcLcLTaugRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPhotongRcOpatcLcLPhotoncOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPhotongRcOpatcLcLPhotongRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLJetgRcOpatcLcLJetcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLJetgRcOpatcLcLJetgRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLMETgRcOpatcLcLMETcOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLMETgRcOpatcLcLMETgRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLParticlegRcOpatcLcLParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLParticlegRcOpatcLcLParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLPFParticlegRcOpatcLcLPFParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements] : new ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefHolderlEedmcLcLReflEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLGenericParticlegRcOpatcLcLGenericParticlegRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > : new ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements] : new ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLRefVectorHolderlEedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > : new ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >;
   }
   static void *newArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements] : new ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete ((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >*)p);
   }
   static void destruct_edmcLcLreftobasecLcLVectorHolderlErecocLcLCandidatecOedmcLcLRefVectorlEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidatecOedmcLcLrefhelpercLcLFindUsingAdvancelEvectorlEpatcLcLCompositeCandidategRcOpatcLcLCompositeCandidategRsPgRsPgR(void *p) {
      typedef ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefProd<vector<pat::PackedCandidate> > : new ::edm::RefProd<vector<pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefProd<vector<pat::PackedCandidate> >[nElements] : new ::edm::RefProd<vector<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::RefProd<vector<pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::RefProd<vector<pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::RefProd<vector<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefProd<vector<pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Association<vector<pat::PackedCandidate> > : new ::edm::Association<vector<pat::PackedCandidate> >;
   }
   static void *newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Association<vector<pat::PackedCandidate> >[nElements] : new ::edm::Association<vector<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((::edm::Association<vector<pat::PackedCandidate> >*)p);
   }
   static void deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((::edm::Association<vector<pat::PackedCandidate> >*)p);
   }
   static void destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef ::edm::Association<vector<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Association<vector<pat::PackedCandidate> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > > : new ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >[nElements] : new ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedCandidategRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefProd<vector<pat::PackedGenParticle> > : new ::edm::RefProd<vector<pat::PackedGenParticle> >;
   }
   static void *newArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RefProd<vector<pat::PackedGenParticle> >[nElements] : new ::edm::RefProd<vector<pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::edm::RefProd<vector<pat::PackedGenParticle> >*)p);
   }
   static void deleteArray_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::edm::RefProd<vector<pat::PackedGenParticle> >*)p);
   }
   static void destruct_edmcLcLRefProdlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::edm::RefProd<vector<pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RefProd<vector<pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Association<vector<pat::PackedGenParticle> > : new ::edm::Association<vector<pat::PackedGenParticle> >;
   }
   static void *newArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Association<vector<pat::PackedGenParticle> >[nElements] : new ::edm::Association<vector<pat::PackedGenParticle> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete ((::edm::Association<vector<pat::PackedGenParticle> >*)p);
   }
   static void deleteArray_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      delete [] ((::edm::Association<vector<pat::PackedGenParticle> >*)p);
   }
   static void destruct_edmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgR(void *p) {
      typedef ::edm::Association<vector<pat::PackedGenParticle> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Association<vector<pat::PackedGenParticle> >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > > : new ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >;
   }
   static void *newArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >[nElements] : new ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEedmcLcLAssociationlEvectorlEpatcLcLPackedGenParticlegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > > : new ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >[nElements] : new ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<edm::Ptr<pat::Jet> > >

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > > : new ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >[nElements] : new ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >

namespace ROOT {
   static TClass *vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary();
   static void vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<edm::Ptr<pat::Jet> > >*)
   {
      vector<vector<edm::Ptr<pat::Jet> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<edm::Ptr<pat::Jet> > >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<edm::Ptr<pat::Jet> > >", -2, "vector", 214,
                  typeid(vector<vector<edm::Ptr<pat::Jet> > >), DefineBehavior(ptr, ptr),
                  &vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<edm::Ptr<pat::Jet> > >) );
      instance.SetNew(&new_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<edm::Ptr<pat::Jet> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<edm::Ptr<pat::Jet> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<vector<edm::Ptr<pat::Jet> > >*)0x0)->GetClass();
      vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<edm::Ptr<pat::Jet> > > : new vector<vector<edm::Ptr<pat::Jet> > >;
   }
   static void *newArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<edm::Ptr<pat::Jet> > >[nElements] : new vector<vector<edm::Ptr<pat::Jet> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      delete ((vector<vector<edm::Ptr<pat::Jet> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<edm::Ptr<pat::Jet> > >*)p);
   }
   static void destruct_vectorlEvectorlEedmcLcLPtrlEpatcLcLJetgRsPgRsPgR(void *p) {
      typedef vector<vector<edm::Ptr<pat::Jet> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<edm::Ptr<pat::Jet> > >

namespace ROOT {
   static TClass *vectorlEpatcLcLtaucLcLTauPFSpecificgR_Dictionary();
   static void vectorlEpatcLcLtaucLcLTauPFSpecificgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p);
   static void deleteArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p);
   static void destruct_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::tau::TauPFSpecific>*)
   {
      vector<pat::tau::TauPFSpecific> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::tau::TauPFSpecific>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::tau::TauPFSpecific>", -2, "vector", 214,
                  typeid(vector<pat::tau::TauPFSpecific>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLtaucLcLTauPFSpecificgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::tau::TauPFSpecific>) );
      instance.SetNew(&new_vectorlEpatcLcLtaucLcLTauPFSpecificgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR);
      instance.SetDelete(&delete_vectorlEpatcLcLtaucLcLTauPFSpecificgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLtaucLcLTauPFSpecificgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::tau::TauPFSpecific> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::tau::TauPFSpecific>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLtaucLcLTauPFSpecificgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::tau::TauPFSpecific>*)0x0)->GetClass();
      vectorlEpatcLcLtaucLcLTauPFSpecificgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLtaucLcLTauPFSpecificgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauPFSpecific> : new vector<pat::tau::TauPFSpecific>;
   }
   static void *newArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauPFSpecific>[nElements] : new vector<pat::tau::TauPFSpecific>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p) {
      delete ((vector<pat::tau::TauPFSpecific>*)p);
   }
   static void deleteArray_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p) {
      delete [] ((vector<pat::tau::TauPFSpecific>*)p);
   }
   static void destruct_vectorlEpatcLcLtaucLcLTauPFSpecificgR(void *p) {
      typedef vector<pat::tau::TauPFSpecific> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::tau::TauPFSpecific>

namespace ROOT {
   static TClass *vectorlEpatcLcLtaucLcLTauPFEssentialgR_Dictionary();
   static void vectorlEpatcLcLtaucLcLTauPFEssentialgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p);
   static void deleteArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p);
   static void destruct_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::tau::TauPFEssential>*)
   {
      vector<pat::tau::TauPFEssential> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::tau::TauPFEssential>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::tau::TauPFEssential>", -2, "vector", 214,
                  typeid(vector<pat::tau::TauPFEssential>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLtaucLcLTauPFEssentialgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::tau::TauPFEssential>) );
      instance.SetNew(&new_vectorlEpatcLcLtaucLcLTauPFEssentialgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR);
      instance.SetDelete(&delete_vectorlEpatcLcLtaucLcLTauPFEssentialgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLtaucLcLTauPFEssentialgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::tau::TauPFEssential> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::tau::TauPFEssential>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLtaucLcLTauPFEssentialgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::tau::TauPFEssential>*)0x0)->GetClass();
      vectorlEpatcLcLtaucLcLTauPFEssentialgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLtaucLcLTauPFEssentialgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauPFEssential> : new vector<pat::tau::TauPFEssential>;
   }
   static void *newArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauPFEssential>[nElements] : new vector<pat::tau::TauPFEssential>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p) {
      delete ((vector<pat::tau::TauPFEssential>*)p);
   }
   static void deleteArray_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p) {
      delete [] ((vector<pat::tau::TauPFEssential>*)p);
   }
   static void destruct_vectorlEpatcLcLtaucLcLTauPFEssentialgR(void *p) {
      typedef vector<pat::tau::TauPFEssential> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::tau::TauPFEssential>

namespace ROOT {
   static TClass *vectorlEpatcLcLtaucLcLTauCaloSpecificgR_Dictionary();
   static void vectorlEpatcLcLtaucLcLTauCaloSpecificgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p);
   static void deleteArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p);
   static void destruct_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::tau::TauCaloSpecific>*)
   {
      vector<pat::tau::TauCaloSpecific> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::tau::TauCaloSpecific>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::tau::TauCaloSpecific>", -2, "vector", 214,
                  typeid(vector<pat::tau::TauCaloSpecific>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLtaucLcLTauCaloSpecificgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::tau::TauCaloSpecific>) );
      instance.SetNew(&new_vectorlEpatcLcLtaucLcLTauCaloSpecificgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR);
      instance.SetDelete(&delete_vectorlEpatcLcLtaucLcLTauCaloSpecificgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLtaucLcLTauCaloSpecificgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::tau::TauCaloSpecific> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::tau::TauCaloSpecific>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLtaucLcLTauCaloSpecificgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::tau::TauCaloSpecific>*)0x0)->GetClass();
      vectorlEpatcLcLtaucLcLTauCaloSpecificgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLtaucLcLTauCaloSpecificgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauCaloSpecific> : new vector<pat::tau::TauCaloSpecific>;
   }
   static void *newArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::tau::TauCaloSpecific>[nElements] : new vector<pat::tau::TauCaloSpecific>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p) {
      delete ((vector<pat::tau::TauCaloSpecific>*)p);
   }
   static void deleteArray_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p) {
      delete [] ((vector<pat::tau::TauCaloSpecific>*)p);
   }
   static void destruct_vectorlEpatcLcLtaucLcLTauCaloSpecificgR(void *p) {
      typedef vector<pat::tau::TauCaloSpecific> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::tau::TauCaloSpecific>

namespace ROOT {
   static TClass *vectorlEpatcLcLTaugR_Dictionary();
   static void vectorlEpatcLcLTaugR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLTaugR(void *p = 0);
   static void *newArray_vectorlEpatcLcLTaugR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLTaugR(void *p);
   static void deleteArray_vectorlEpatcLcLTaugR(void *p);
   static void destruct_vectorlEpatcLcLTaugR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Tau>*)
   {
      vector<pat::Tau> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Tau>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Tau>", -2, "vector", 214,
                  typeid(vector<pat::Tau>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLTaugR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Tau>) );
      instance.SetNew(&new_vectorlEpatcLcLTaugR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLTaugR);
      instance.SetDelete(&delete_vectorlEpatcLcLTaugR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLTaugR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLTaugR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Tau> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Tau>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLTaugR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Tau>*)0x0)->GetClass();
      vectorlEpatcLcLTaugR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLTaugR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLTaugR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Tau> : new vector<pat::Tau>;
   }
   static void *newArray_vectorlEpatcLcLTaugR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Tau>[nElements] : new vector<pat::Tau>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLTaugR(void *p) {
      delete ((vector<pat::Tau>*)p);
   }
   static void deleteArray_vectorlEpatcLcLTaugR(void *p) {
      delete [] ((vector<pat::Tau>*)p);
   }
   static void destruct_vectorlEpatcLcLTaugR(void *p) {
      typedef vector<pat::Tau> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Tau>

namespace ROOT {
   static TClass *vectorlEpatcLcLPhotongR_Dictionary();
   static void vectorlEpatcLcLPhotongR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLPhotongR(void *p = 0);
   static void *newArray_vectorlEpatcLcLPhotongR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLPhotongR(void *p);
   static void deleteArray_vectorlEpatcLcLPhotongR(void *p);
   static void destruct_vectorlEpatcLcLPhotongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Photon>*)
   {
      vector<pat::Photon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Photon>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Photon>", -2, "vector", 214,
                  typeid(vector<pat::Photon>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLPhotongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Photon>) );
      instance.SetNew(&new_vectorlEpatcLcLPhotongR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLPhotongR);
      instance.SetDelete(&delete_vectorlEpatcLcLPhotongR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLPhotongR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLPhotongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Photon> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Photon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLPhotongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Photon>*)0x0)->GetClass();
      vectorlEpatcLcLPhotongR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLPhotongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLPhotongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Photon> : new vector<pat::Photon>;
   }
   static void *newArray_vectorlEpatcLcLPhotongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Photon>[nElements] : new vector<pat::Photon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLPhotongR(void *p) {
      delete ((vector<pat::Photon>*)p);
   }
   static void deleteArray_vectorlEpatcLcLPhotongR(void *p) {
      delete [] ((vector<pat::Photon>*)p);
   }
   static void destruct_vectorlEpatcLcLPhotongR(void *p) {
      typedef vector<pat::Photon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Photon>

namespace ROOT {
   static TClass *vectorlEpatcLcLParticlegR_Dictionary();
   static void vectorlEpatcLcLParticlegR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLParticlegR(void *p = 0);
   static void *newArray_vectorlEpatcLcLParticlegR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLParticlegR(void *p);
   static void deleteArray_vectorlEpatcLcLParticlegR(void *p);
   static void destruct_vectorlEpatcLcLParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Particle>*)
   {
      vector<pat::Particle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Particle>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Particle>", -2, "vector", 214,
                  typeid(vector<pat::Particle>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Particle>) );
      instance.SetNew(&new_vectorlEpatcLcLParticlegR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLParticlegR);
      instance.SetDelete(&delete_vectorlEpatcLcLParticlegR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLParticlegR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLParticlegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Particle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Particle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Particle>*)0x0)->GetClass();
      vectorlEpatcLcLParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLParticlegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Particle> : new vector<pat::Particle>;
   }
   static void *newArray_vectorlEpatcLcLParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Particle>[nElements] : new vector<pat::Particle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLParticlegR(void *p) {
      delete ((vector<pat::Particle>*)p);
   }
   static void deleteArray_vectorlEpatcLcLParticlegR(void *p) {
      delete [] ((vector<pat::Particle>*)p);
   }
   static void destruct_vectorlEpatcLcLParticlegR(void *p) {
      typedef vector<pat::Particle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Particle>

namespace ROOT {
   static TClass *vectorlEpatcLcLPackedGenParticlegR_Dictionary();
   static void vectorlEpatcLcLPackedGenParticlegR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLPackedGenParticlegR(void *p = 0);
   static void *newArray_vectorlEpatcLcLPackedGenParticlegR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLPackedGenParticlegR(void *p);
   static void deleteArray_vectorlEpatcLcLPackedGenParticlegR(void *p);
   static void destruct_vectorlEpatcLcLPackedGenParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::PackedGenParticle>*)
   {
      vector<pat::PackedGenParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::PackedGenParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::PackedGenParticle>", -2, "vector", 214,
                  typeid(vector<pat::PackedGenParticle>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLPackedGenParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::PackedGenParticle>) );
      instance.SetNew(&new_vectorlEpatcLcLPackedGenParticlegR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLPackedGenParticlegR);
      instance.SetDelete(&delete_vectorlEpatcLcLPackedGenParticlegR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLPackedGenParticlegR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLPackedGenParticlegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::PackedGenParticle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::PackedGenParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLPackedGenParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::PackedGenParticle>*)0x0)->GetClass();
      vectorlEpatcLcLPackedGenParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLPackedGenParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLPackedGenParticlegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PackedGenParticle> : new vector<pat::PackedGenParticle>;
   }
   static void *newArray_vectorlEpatcLcLPackedGenParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PackedGenParticle>[nElements] : new vector<pat::PackedGenParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLPackedGenParticlegR(void *p) {
      delete ((vector<pat::PackedGenParticle>*)p);
   }
   static void deleteArray_vectorlEpatcLcLPackedGenParticlegR(void *p) {
      delete [] ((vector<pat::PackedGenParticle>*)p);
   }
   static void destruct_vectorlEpatcLcLPackedGenParticlegR(void *p) {
      typedef vector<pat::PackedGenParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::PackedGenParticle>

namespace ROOT {
   static TClass *vectorlEpatcLcLPackedCandidategR_Dictionary();
   static void vectorlEpatcLcLPackedCandidategR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLPackedCandidategR(void *p = 0);
   static void *newArray_vectorlEpatcLcLPackedCandidategR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLPackedCandidategR(void *p);
   static void deleteArray_vectorlEpatcLcLPackedCandidategR(void *p);
   static void destruct_vectorlEpatcLcLPackedCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::PackedCandidate>*)
   {
      vector<pat::PackedCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::PackedCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::PackedCandidate>", -2, "vector", 214,
                  typeid(vector<pat::PackedCandidate>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLPackedCandidategR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::PackedCandidate>) );
      instance.SetNew(&new_vectorlEpatcLcLPackedCandidategR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLPackedCandidategR);
      instance.SetDelete(&delete_vectorlEpatcLcLPackedCandidategR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLPackedCandidategR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLPackedCandidategR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::PackedCandidate> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::PackedCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLPackedCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::PackedCandidate>*)0x0)->GetClass();
      vectorlEpatcLcLPackedCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLPackedCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLPackedCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PackedCandidate> : new vector<pat::PackedCandidate>;
   }
   static void *newArray_vectorlEpatcLcLPackedCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PackedCandidate>[nElements] : new vector<pat::PackedCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLPackedCandidategR(void *p) {
      delete ((vector<pat::PackedCandidate>*)p);
   }
   static void deleteArray_vectorlEpatcLcLPackedCandidategR(void *p) {
      delete [] ((vector<pat::PackedCandidate>*)p);
   }
   static void destruct_vectorlEpatcLcLPackedCandidategR(void *p) {
      typedef vector<pat::PackedCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::PackedCandidate>

namespace ROOT {
   static TClass *vectorlEpatcLcLPFParticlegR_Dictionary();
   static void vectorlEpatcLcLPFParticlegR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLPFParticlegR(void *p = 0);
   static void *newArray_vectorlEpatcLcLPFParticlegR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLPFParticlegR(void *p);
   static void deleteArray_vectorlEpatcLcLPFParticlegR(void *p);
   static void destruct_vectorlEpatcLcLPFParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::PFParticle>*)
   {
      vector<pat::PFParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::PFParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::PFParticle>", -2, "vector", 214,
                  typeid(vector<pat::PFParticle>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLPFParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::PFParticle>) );
      instance.SetNew(&new_vectorlEpatcLcLPFParticlegR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLPFParticlegR);
      instance.SetDelete(&delete_vectorlEpatcLcLPFParticlegR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLPFParticlegR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLPFParticlegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::PFParticle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::PFParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLPFParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::PFParticle>*)0x0)->GetClass();
      vectorlEpatcLcLPFParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLPFParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLPFParticlegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PFParticle> : new vector<pat::PFParticle>;
   }
   static void *newArray_vectorlEpatcLcLPFParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::PFParticle>[nElements] : new vector<pat::PFParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLPFParticlegR(void *p) {
      delete ((vector<pat::PFParticle>*)p);
   }
   static void deleteArray_vectorlEpatcLcLPFParticlegR(void *p) {
      delete [] ((vector<pat::PFParticle>*)p);
   }
   static void destruct_vectorlEpatcLcLPFParticlegR(void *p) {
      typedef vector<pat::PFParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::PFParticle>

namespace ROOT {
   static TClass *vectorlEpatcLcLMuongR_Dictionary();
   static void vectorlEpatcLcLMuongR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLMuongR(void *p = 0);
   static void *newArray_vectorlEpatcLcLMuongR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLMuongR(void *p);
   static void deleteArray_vectorlEpatcLcLMuongR(void *p);
   static void destruct_vectorlEpatcLcLMuongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Muon>*)
   {
      vector<pat::Muon> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Muon>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Muon>", -2, "vector", 214,
                  typeid(vector<pat::Muon>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLMuongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Muon>) );
      instance.SetNew(&new_vectorlEpatcLcLMuongR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLMuongR);
      instance.SetDelete(&delete_vectorlEpatcLcLMuongR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLMuongR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLMuongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Muon> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Muon>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLMuongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Muon>*)0x0)->GetClass();
      vectorlEpatcLcLMuongR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLMuongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLMuongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Muon> : new vector<pat::Muon>;
   }
   static void *newArray_vectorlEpatcLcLMuongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Muon>[nElements] : new vector<pat::Muon>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLMuongR(void *p) {
      delete ((vector<pat::Muon>*)p);
   }
   static void deleteArray_vectorlEpatcLcLMuongR(void *p) {
      delete [] ((vector<pat::Muon>*)p);
   }
   static void destruct_vectorlEpatcLcLMuongR(void *p) {
      typedef vector<pat::Muon> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Muon>

namespace ROOT {
   static TClass *vectorlEpatcLcLMHTgR_Dictionary();
   static void vectorlEpatcLcLMHTgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLMHTgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLMHTgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLMHTgR(void *p);
   static void deleteArray_vectorlEpatcLcLMHTgR(void *p);
   static void destruct_vectorlEpatcLcLMHTgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::MHT>*)
   {
      vector<pat::MHT> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::MHT>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::MHT>", -2, "vector", 214,
                  typeid(vector<pat::MHT>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLMHTgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::MHT>) );
      instance.SetNew(&new_vectorlEpatcLcLMHTgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLMHTgR);
      instance.SetDelete(&delete_vectorlEpatcLcLMHTgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLMHTgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLMHTgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::MHT> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::MHT>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLMHTgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::MHT>*)0x0)->GetClass();
      vectorlEpatcLcLMHTgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLMHTgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLMHTgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MHT> : new vector<pat::MHT>;
   }
   static void *newArray_vectorlEpatcLcLMHTgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MHT>[nElements] : new vector<pat::MHT>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLMHTgR(void *p) {
      delete ((vector<pat::MHT>*)p);
   }
   static void deleteArray_vectorlEpatcLcLMHTgR(void *p) {
      delete [] ((vector<pat::MHT>*)p);
   }
   static void destruct_vectorlEpatcLcLMHTgR(void *p) {
      typedef vector<pat::MHT> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::MHT>

namespace ROOT {
   static TClass *vectorlEpatcLcLMETgR_Dictionary();
   static void vectorlEpatcLcLMETgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLMETgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLMETgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLMETgR(void *p);
   static void deleteArray_vectorlEpatcLcLMETgR(void *p);
   static void destruct_vectorlEpatcLcLMETgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::MET>*)
   {
      vector<pat::MET> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::MET>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::MET>", -2, "vector", 214,
                  typeid(vector<pat::MET>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLMETgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::MET>) );
      instance.SetNew(&new_vectorlEpatcLcLMETgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLMETgR);
      instance.SetDelete(&delete_vectorlEpatcLcLMETgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLMETgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLMETgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::MET> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::MET>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLMETgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::MET>*)0x0)->GetClass();
      vectorlEpatcLcLMETgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLMETgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLMETgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MET> : new vector<pat::MET>;
   }
   static void *newArray_vectorlEpatcLcLMETgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MET>[nElements] : new vector<pat::MET>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLMETgR(void *p) {
      delete ((vector<pat::MET>*)p);
   }
   static void deleteArray_vectorlEpatcLcLMETgR(void *p) {
      delete [] ((vector<pat::MET>*)p);
   }
   static void destruct_vectorlEpatcLcLMETgR(void *p) {
      typedef vector<pat::MET> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::MET>

namespace ROOT {
   static TClass *vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_Dictionary();
   static void vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p = 0);
   static void *newArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p);
   static void deleteArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p);
   static void destruct_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::MET::PackedMETUncertainty>*)
   {
      vector<pat::MET::PackedMETUncertainty> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::MET::PackedMETUncertainty>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::MET::PackedMETUncertainty>", -2, "vector", 214,
                  typeid(vector<pat::MET::PackedMETUncertainty>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::MET::PackedMETUncertainty>) );
      instance.SetNew(&new_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR);
      instance.SetDelete(&delete_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::MET::PackedMETUncertainty> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::MET::PackedMETUncertainty>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::MET::PackedMETUncertainty>*)0x0)->GetClass();
      vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLMETcLcLPackedMETUncertaintygR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MET::PackedMETUncertainty> : new vector<pat::MET::PackedMETUncertainty>;
   }
   static void *newArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::MET::PackedMETUncertainty>[nElements] : new vector<pat::MET::PackedMETUncertainty>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p) {
      delete ((vector<pat::MET::PackedMETUncertainty>*)p);
   }
   static void deleteArray_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p) {
      delete [] ((vector<pat::MET::PackedMETUncertainty>*)p);
   }
   static void destruct_vectorlEpatcLcLMETcLcLPackedMETUncertaintygR(void *p) {
      typedef vector<pat::MET::PackedMETUncertainty> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::MET::PackedMETUncertainty>

namespace ROOT {
   static TClass *vectorlEpatcLcLJetgR_Dictionary();
   static void vectorlEpatcLcLJetgR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLJetgR(void *p = 0);
   static void *newArray_vectorlEpatcLcLJetgR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLJetgR(void *p);
   static void deleteArray_vectorlEpatcLcLJetgR(void *p);
   static void destruct_vectorlEpatcLcLJetgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Jet>*)
   {
      vector<pat::Jet> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Jet>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Jet>", -2, "vector", 214,
                  typeid(vector<pat::Jet>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLJetgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Jet>) );
      instance.SetNew(&new_vectorlEpatcLcLJetgR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLJetgR);
      instance.SetDelete(&delete_vectorlEpatcLcLJetgR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLJetgR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLJetgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Jet> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Jet>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLJetgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Jet>*)0x0)->GetClass();
      vectorlEpatcLcLJetgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLJetgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLJetgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Jet> : new vector<pat::Jet>;
   }
   static void *newArray_vectorlEpatcLcLJetgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Jet>[nElements] : new vector<pat::Jet>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLJetgR(void *p) {
      delete ((vector<pat::Jet>*)p);
   }
   static void deleteArray_vectorlEpatcLcLJetgR(void *p) {
      delete [] ((vector<pat::Jet>*)p);
   }
   static void destruct_vectorlEpatcLcLJetgR(void *p) {
      typedef vector<pat::Jet> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Jet>

namespace ROOT {
   static TClass *vectorlEpatcLcLHemispheregR_Dictionary();
   static void vectorlEpatcLcLHemispheregR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLHemispheregR(void *p = 0);
   static void *newArray_vectorlEpatcLcLHemispheregR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLHemispheregR(void *p);
   static void deleteArray_vectorlEpatcLcLHemispheregR(void *p);
   static void destruct_vectorlEpatcLcLHemispheregR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Hemisphere>*)
   {
      vector<pat::Hemisphere> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Hemisphere>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Hemisphere>", -2, "vector", 214,
                  typeid(vector<pat::Hemisphere>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLHemispheregR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Hemisphere>) );
      instance.SetNew(&new_vectorlEpatcLcLHemispheregR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLHemispheregR);
      instance.SetDelete(&delete_vectorlEpatcLcLHemispheregR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLHemispheregR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLHemispheregR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Hemisphere> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Hemisphere>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLHemispheregR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Hemisphere>*)0x0)->GetClass();
      vectorlEpatcLcLHemispheregR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLHemispheregR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLHemispheregR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Hemisphere> : new vector<pat::Hemisphere>;
   }
   static void *newArray_vectorlEpatcLcLHemispheregR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Hemisphere>[nElements] : new vector<pat::Hemisphere>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLHemispheregR(void *p) {
      delete ((vector<pat::Hemisphere>*)p);
   }
   static void deleteArray_vectorlEpatcLcLHemispheregR(void *p) {
      delete [] ((vector<pat::Hemisphere>*)p);
   }
   static void destruct_vectorlEpatcLcLHemispheregR(void *p) {
      typedef vector<pat::Hemisphere> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Hemisphere>

namespace ROOT {
   static TClass *vectorlEpatcLcLGenericParticlegR_Dictionary();
   static void vectorlEpatcLcLGenericParticlegR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLGenericParticlegR(void *p = 0);
   static void *newArray_vectorlEpatcLcLGenericParticlegR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLGenericParticlegR(void *p);
   static void deleteArray_vectorlEpatcLcLGenericParticlegR(void *p);
   static void destruct_vectorlEpatcLcLGenericParticlegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::GenericParticle>*)
   {
      vector<pat::GenericParticle> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::GenericParticle>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::GenericParticle>", -2, "vector", 214,
                  typeid(vector<pat::GenericParticle>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLGenericParticlegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::GenericParticle>) );
      instance.SetNew(&new_vectorlEpatcLcLGenericParticlegR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLGenericParticlegR);
      instance.SetDelete(&delete_vectorlEpatcLcLGenericParticlegR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLGenericParticlegR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLGenericParticlegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::GenericParticle> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::GenericParticle>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLGenericParticlegR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::GenericParticle>*)0x0)->GetClass();
      vectorlEpatcLcLGenericParticlegR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLGenericParticlegR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLGenericParticlegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::GenericParticle> : new vector<pat::GenericParticle>;
   }
   static void *newArray_vectorlEpatcLcLGenericParticlegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::GenericParticle>[nElements] : new vector<pat::GenericParticle>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLGenericParticlegR(void *p) {
      delete ((vector<pat::GenericParticle>*)p);
   }
   static void deleteArray_vectorlEpatcLcLGenericParticlegR(void *p) {
      delete [] ((vector<pat::GenericParticle>*)p);
   }
   static void destruct_vectorlEpatcLcLGenericParticlegR(void *p) {
      typedef vector<pat::GenericParticle> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::GenericParticle>

namespace ROOT {
   static TClass *vectorlEpatcLcLElectrongR_Dictionary();
   static void vectorlEpatcLcLElectrongR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLElectrongR(void *p = 0);
   static void *newArray_vectorlEpatcLcLElectrongR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLElectrongR(void *p);
   static void deleteArray_vectorlEpatcLcLElectrongR(void *p);
   static void destruct_vectorlEpatcLcLElectrongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Electron>*)
   {
      vector<pat::Electron> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Electron>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Electron>", -2, "vector", 214,
                  typeid(vector<pat::Electron>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLElectrongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Electron>) );
      instance.SetNew(&new_vectorlEpatcLcLElectrongR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLElectrongR);
      instance.SetDelete(&delete_vectorlEpatcLcLElectrongR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLElectrongR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLElectrongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Electron> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Electron>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLElectrongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Electron>*)0x0)->GetClass();
      vectorlEpatcLcLElectrongR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLElectrongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLElectrongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Electron> : new vector<pat::Electron>;
   }
   static void *newArray_vectorlEpatcLcLElectrongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Electron>[nElements] : new vector<pat::Electron>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLElectrongR(void *p) {
      delete ((vector<pat::Electron>*)p);
   }
   static void deleteArray_vectorlEpatcLcLElectrongR(void *p) {
      delete [] ((vector<pat::Electron>*)p);
   }
   static void destruct_vectorlEpatcLcLElectrongR(void *p) {
      typedef vector<pat::Electron> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Electron>

namespace ROOT {
   static TClass *vectorlEpatcLcLConversiongR_Dictionary();
   static void vectorlEpatcLcLConversiongR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLConversiongR(void *p = 0);
   static void *newArray_vectorlEpatcLcLConversiongR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLConversiongR(void *p);
   static void deleteArray_vectorlEpatcLcLConversiongR(void *p);
   static void destruct_vectorlEpatcLcLConversiongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::Conversion>*)
   {
      vector<pat::Conversion> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::Conversion>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::Conversion>", -2, "vector", 214,
                  typeid(vector<pat::Conversion>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLConversiongR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::Conversion>) );
      instance.SetNew(&new_vectorlEpatcLcLConversiongR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLConversiongR);
      instance.SetDelete(&delete_vectorlEpatcLcLConversiongR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLConversiongR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLConversiongR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::Conversion> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::Conversion>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLConversiongR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::Conversion>*)0x0)->GetClass();
      vectorlEpatcLcLConversiongR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLConversiongR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLConversiongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Conversion> : new vector<pat::Conversion>;
   }
   static void *newArray_vectorlEpatcLcLConversiongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::Conversion>[nElements] : new vector<pat::Conversion>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLConversiongR(void *p) {
      delete ((vector<pat::Conversion>*)p);
   }
   static void deleteArray_vectorlEpatcLcLConversiongR(void *p) {
      delete [] ((vector<pat::Conversion>*)p);
   }
   static void destruct_vectorlEpatcLcLConversiongR(void *p) {
      typedef vector<pat::Conversion> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::Conversion>

namespace ROOT {
   static TClass *vectorlEpatcLcLCompositeCandidategR_Dictionary();
   static void vectorlEpatcLcLCompositeCandidategR_TClassManip(TClass*);
   static void *new_vectorlEpatcLcLCompositeCandidategR(void *p = 0);
   static void *newArray_vectorlEpatcLcLCompositeCandidategR(Long_t size, void *p);
   static void delete_vectorlEpatcLcLCompositeCandidategR(void *p);
   static void deleteArray_vectorlEpatcLcLCompositeCandidategR(void *p);
   static void destruct_vectorlEpatcLcLCompositeCandidategR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<pat::CompositeCandidate>*)
   {
      vector<pat::CompositeCandidate> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<pat::CompositeCandidate>));
      static ::ROOT::TGenericClassInfo 
         instance("vector<pat::CompositeCandidate>", -2, "vector", 214,
                  typeid(vector<pat::CompositeCandidate>), DefineBehavior(ptr, ptr),
                  &vectorlEpatcLcLCompositeCandidategR_Dictionary, isa_proxy, 4,
                  sizeof(vector<pat::CompositeCandidate>) );
      instance.SetNew(&new_vectorlEpatcLcLCompositeCandidategR);
      instance.SetNewArray(&newArray_vectorlEpatcLcLCompositeCandidategR);
      instance.SetDelete(&delete_vectorlEpatcLcLCompositeCandidategR);
      instance.SetDeleteArray(&deleteArray_vectorlEpatcLcLCompositeCandidategR);
      instance.SetDestructor(&destruct_vectorlEpatcLcLCompositeCandidategR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<pat::CompositeCandidate> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<pat::CompositeCandidate>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEpatcLcLCompositeCandidategR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<pat::CompositeCandidate>*)0x0)->GetClass();
      vectorlEpatcLcLCompositeCandidategR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEpatcLcLCompositeCandidategR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEpatcLcLCompositeCandidategR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::CompositeCandidate> : new vector<pat::CompositeCandidate>;
   }
   static void *newArray_vectorlEpatcLcLCompositeCandidategR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<pat::CompositeCandidate>[nElements] : new vector<pat::CompositeCandidate>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEpatcLcLCompositeCandidategR(void *p) {
      delete ((vector<pat::CompositeCandidate>*)p);
   }
   static void deleteArray_vectorlEpatcLcLCompositeCandidategR(void *p) {
      delete [] ((vector<pat::CompositeCandidate>*)p);
   }
   static void destruct_vectorlEpatcLcLCompositeCandidategR(void *p) {
      typedef vector<pat::CompositeCandidate> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<pat::CompositeCandidate>

namespace ROOT {
   static TClass *vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_Dictionary();
   static void vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p);
   static void destruct_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::Ptr<pat::Jet> >*)
   {
      vector<edm::Ptr<pat::Jet> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::Ptr<pat::Jet> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::Ptr<pat::Jet> >", -2, "vector", 214,
                  typeid(vector<edm::Ptr<pat::Jet> >), DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::Ptr<pat::Jet> >) );
      instance.SetNew(&new_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::Ptr<pat::Jet> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<edm::Ptr<pat::Jet> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::Ptr<pat::Jet> >*)0x0)->GetClass();
      vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<edm::Ptr<pat::Jet> > : new vector<edm::Ptr<pat::Jet> >;
   }
   static void *newArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<edm::Ptr<pat::Jet> >[nElements] : new vector<edm::Ptr<pat::Jet> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p) {
      delete ((vector<edm::Ptr<pat::Jet> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p) {
      delete [] ((vector<edm::Ptr<pat::Jet> >*)p);
   }
   static void destruct_vectorlEedmcLcLPtrlEpatcLcLJetgRsPgR(void *p) {
      typedef vector<edm::Ptr<pat::Jet> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::Ptr<pat::Jet> >

namespace ROOT {
   static TClass *vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary();
   static void vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass*);
   static void *new_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p = 0);
   static void *newArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(Long_t size, void *p);
   static void delete_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);
   static void deleteArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);
   static void destruct_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<edm::FwdPtr<pat::PackedCandidate> >*)
   {
      vector<edm::FwdPtr<pat::PackedCandidate> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<edm::FwdPtr<pat::PackedCandidate> >));
      static ::ROOT::TGenericClassInfo 
         instance("vector<edm::FwdPtr<pat::PackedCandidate> >", -2, "vector", 214,
                  typeid(vector<edm::FwdPtr<pat::PackedCandidate> >), DefineBehavior(ptr, ptr),
                  &vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<edm::FwdPtr<pat::PackedCandidate> >) );
      instance.SetNew(&new_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetNewArray(&newArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDelete(&delete_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.SetDestructor(&destruct_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<edm::FwdPtr<pat::PackedCandidate> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<edm::FwdPtr<pat::PackedCandidate> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static TClass *vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_Dictionary() {
      TClass* theClass =::ROOT::GenerateInitInstanceLocal((const vector<edm::FwdPtr<pat::PackedCandidate> >*)0x0)->GetClass();
      vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(theClass);
   return theClass;
   }

   static void vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR_TClassManip(TClass* ){
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<edm::FwdPtr<pat::PackedCandidate> > : new vector<edm::FwdPtr<pat::PackedCandidate> >;
   }
   static void *newArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<edm::FwdPtr<pat::PackedCandidate> >[nElements] : new vector<edm::FwdPtr<pat::PackedCandidate> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete ((vector<edm::FwdPtr<pat::PackedCandidate> >*)p);
   }
   static void deleteArray_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      delete [] ((vector<edm::FwdPtr<pat::PackedCandidate> >*)p);
   }
   static void destruct_vectorlEedmcLcLFwdPtrlEpatcLcLPackedCandidategRsPgR(void *p) {
      typedef vector<edm::FwdPtr<pat::PackedCandidate> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<edm::FwdPtr<pat::PackedCandidate> >

namespace {
  void TriggerDictionaryInitialization_DataFormatsPatCandidates_x3r_Impl() {
    static const char* headers[] = {
0    };
    static const char* includePaths[] = {
"/shome/jngadiub/EXOVVAnalysisRunII/TagAndProbe/CMSSW_7_4_7/src",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/cms/cmssw/CMSSW_7_4_7/src",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/lcg/root/6.02.00-odfocd5/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/pcre/7.9__8.33-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/boost/1.57.0-jlbgio/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/bz2lib/1.0.5-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/clhep/2.1.4.1-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/gsl/1.10-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/hepmc/2.06.07-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/libuuid/2.22.2-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/tbb/43_20141023oss/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/external/zlib/1.2.8-cms/include",
"/cvmfs/cms.cern.ch/slc6_amd64_gcc491/lcg/root/6.02.00-odfocd5/include",
"/shome/jngadiub/EXOVVAnalysisRunII/TagAndProbe/CMSSW_7_4_7/",
0
    };
    static const char* fwdDeclCode = 
R"DICTFWDDCLS(
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_Autoloading_Map;
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  GsfElectron;}
namespace pat{template <class ObjectType> class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  PATObject;
}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  Muon;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  BaseTau;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Photon.h")))  Photon;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  Jet;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/MET.h")))  MET;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  LeafCandidate;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  CompositeCandidate;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  PFCandidate;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  RecoCandidate;}
namespace pat{template <class LeptonType> class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  Lepton;
}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  Electron;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  SuperCluster;}
namespace std{template <typename _Tp> class __attribute__((annotate("$clingAutoload$string")))  allocator;
}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Muon.h")))  Muon;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  Tau;}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  Track;}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  Ptr;
}
namespace pat{namespace tau{struct __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  TauPFSpecific;}}
namespace pat{namespace tau{struct __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  TauCaloSpecific;}}
namespace pat{namespace tau{struct __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Tau.h")))  TauPFEssential;}}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Photon.h")))  Photon;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Jet.h")))  Jet;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/MET.h")))  MET;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/MHT.h")))  MHT;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Particle.h")))  Particle;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/CompositeCandidate.h")))  CompositeCandidate;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/PFParticle.h")))  PFParticle;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/GenericParticle.h")))  GenericParticle;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Hemisphere.h")))  Hemisphere;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Conversion.h")))  Conversion;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  PackedCandidate;}
namespace pat{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/PackedGenParticle.h")))  PackedGenParticle;}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/FwdPtr.h")))  FwdPtr;
}
namespace edm{template <typename T> class __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  Wrapper;
}
namespace edm{namespace refhelper{template <typename C, typename T> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  FindUsingAdvance;
}}
namespace edm{namespace refhelper{template <typename REFV> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  FindRefVectorUsingAdvance;
}}
namespace edm{namespace refhelper{template <typename C, typename T> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  FindTrait;
}}
namespace edm{namespace refhelper{template <typename C> struct __attribute__((annotate("$clingAutoload$DataFormats/Common/interface/Association.h")))  ValueTrait;
}}
namespace reco{class __attribute__((annotate("$clingAutoload$DataFormats/PatCandidates/interface/Electron.h")))  Candidate;}
)DICTFWDDCLS";
    static const char* payloadCode = R"DICTPAYLOAD(

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef CMS_DICT_IMPL
  #define CMS_DICT_IMPL 1
#endif
#ifndef _REENTRANT
  #define _REENTRANT 1
#endif
#ifndef GNUSOURCE
  #define GNUSOURCE 1
#endif
#ifndef __STRICT_ANSI__
  #define __STRICT_ANSI__ 1
#endif
#ifndef GNU_GCC
  #define GNU_GCC 1
#endif
#ifndef _GNU_SOURCE
  #define _GNU_SOURCE 1
#endif
#ifndef CMSSW_GIT_HASH
  #define CMSSW_GIT_HASH "CMSSW_7_4_7"
#endif
#ifndef PROJECT_NAME
  #define PROJECT_NAME "CMSSW"
#endif
#ifndef PROJECT_VERSION
  #define PROJECT_VERSION "CMSSW_7_4_7"
#endif
#ifndef BOOST_SPIRIT_THREADSAFE
  #define BOOST_SPIRIT_THREADSAFE 1
#endif
#ifndef PHOENIX_THREADSAFE
  #define PHOENIX_THREADSAFE 1
#endif
#ifndef CMSSW_REFLEX_DICT
  #define CMSSW_REFLEX_DICT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
#include "DataFormats/Common/interface/ValueMap.h"
#include "DataFormats/Common/interface/Association.h"
#include "DataFormats/Common/interface/Wrapper.h"
#include "DataFormats/Common/interface/PtrVector.h"
#include "DataFormats/Common/interface/FwdPtr.h"

#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/MHT.h"
#include "DataFormats/PatCandidates/interface/Particle.h"
#include "DataFormats/PatCandidates/interface/CompositeCandidate.h"
#include "DataFormats/PatCandidates/interface/PFParticle.h"
#include "DataFormats/PatCandidates/interface/GenericParticle.h"
#include "DataFormats/PatCandidates/interface/Hemisphere.h"
#include "DataFormats/PatCandidates/interface/Conversion.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"
#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"

namespace DataFormats_PatCandidates {
  struct dictionaryobjects {

  /*   PAT Object Collection Iterators   */
  std::vector<pat::Electron>::const_iterator	    v_p_e_ci;
  std::vector<pat::Muon>::const_iterator	    v_p_mu_ci;
  std::vector<pat::Tau>::const_iterator	            v_p_t_ci;
  std::vector<pat::Photon>::const_iterator	    v_p_ph_ci;
  std::vector<pat::Jet>::const_iterator	            v_p_j_ci;
  std::vector<pat::MET>::const_iterator	            v_p_m_ci;
  std::vector<pat::MHT>::const_iterator	            v_p_mht_ci;
  std::vector<pat::Particle>::const_iterator	    v_p_p_ci;
  std::vector<pat::CompositeCandidate>::const_iterator	v_p_cc_ci;
  std::vector<pat::PFParticle>::const_iterator	    v_p_pfp_ci;
  std::vector<pat::GenericParticle>::const_iterator v_p_gp_ci;
  std::vector<pat::Hemisphere>::const_iterator	    v_p_h_ci;
  std::vector<pat::Conversion>::const_iterator      v_p_c_ci;
  std::vector<pat::PackedCandidate>::const_iterator      v_p_pc_ci;
  std::vector<pat::PackedGenParticle>::const_iterator      v_p_pgc_ci;

  /*   PAT Object Collection Wrappers   */
  edm::Wrapper<std::vector<pat::Electron> >	    w_v_p_e;
  edm::Wrapper<std::vector<pat::Muon> >	            w_v_p_mu;
  edm::Wrapper<std::vector<pat::Tau> >	            w_v_p_t;
  edm::Wrapper<std::vector<pat::Photon> >	    w_v_p_ph;
  edm::Wrapper<std::vector<pat::Jet> >	            w_v_p_j;
  edm::Wrapper<std::vector<pat::MET> >	            w_v_p_m;
  edm::Wrapper<std::vector<pat::MHT> >	            w_v_p_mht;
  edm::Wrapper<std::vector<pat::Particle> >	    w_v_p_p;
  edm::Wrapper<std::vector<pat::CompositeCandidate> > w_v_cc_p;
  edm::Wrapper<std::vector<pat::PFParticle> >	    w_v_p_pfp;
  edm::Wrapper<std::vector<pat::GenericParticle> >  w_v_p_gp;
  edm::Wrapper<std::vector<pat::Hemisphere> >	    w_v_p_h;
  edm::Wrapper<std::vector<pat::Conversion> >       w_v_p_c;
  edm::Wrapper<std::vector<pat::PackedCandidate> >       w_v_pc_c;
  edm::Wrapper<std::vector<pat::PackedGenParticle> >       w_v_pgc_c;

  /*   PAT Object References   */
  pat::ElectronRef	    p_r_e;
  pat::MuonRef	            p_r_mu;
  pat::TauRef	            p_r_t;
  pat::PhotonRef	    p_r_ph;
  pat::JetRef	            p_r_j;
  pat::METRef	            p_r_m;
  pat::ParticleRef	    p_r_p;
  pat::CompositeCandidateRef	    p_r_cc;
  pat::PFParticleRef	    p_r_pgp;
  pat::GenericParticleRef   p_r_gp;
  pat::HemisphereRef	    p_r_h;
  pat::ConversionRef        p_r_c;
  pat::PackedCandidateRef        p_r_pc;
  pat::PackedGenParticleRef        p_r_pcg;

  /*   PAT Object Ref Vector Wrappers   */
  edm::Wrapper<pat::ElectronRefVector>	        p_rv_e;
  edm::Wrapper<pat::MuonRefVector>	        p_rv_mu;
  edm::Wrapper<pat::TauRefVector>	        p_rv_t;
  edm::Wrapper<pat::PhotonRefVector>	        p_rv_ph;
  edm::Wrapper<pat::JetRefVector>	        p_rv_j;
  edm::Wrapper<pat::METRefVector>	        p_rv_m;
  edm::Wrapper<pat::ParticleRefVector>	        p_rv_p;
  edm::Wrapper<pat::CompositeCandidateRefVector> p_rv_cc;
  edm::Wrapper<pat::PFParticleRefVector>	p_rv_pgp;
  edm::Wrapper<pat::GenericParticleRefVector>   p_rv_gp;
  edm::Wrapper<pat::HemisphereRefVector>	p_rv_h;
  edm::Wrapper<pat::ConversionRefVector>        p_rv_c;
  edm::Wrapper<pat::PackedCandidateRefVector>        p_rv_pc;
  edm::Wrapper<pat::PackedGenParticleRefVector>        p_rv_pcg;

  /*   RefToBase<Candidate> from PATObjects   */
    /*   With direct Holder   */
  edm::reftobase::Holder<reco::Candidate, pat::ElectronRef>	 	rb_cand_h_p_e;
  edm::reftobase::Holder<reco::Candidate, pat::MuonRef>	         	rb_cand_h_p_mu;
  edm::reftobase::Holder<reco::Candidate, pat::TauRef>	         	rb_cand_h_p_t;
  edm::reftobase::Holder<reco::Candidate, pat::PhotonRef>	 	rb_cand_h_p_ph;
  edm::reftobase::Holder<reco::Candidate, pat::JetRef>	         	rb_cand_h_p_j;
  edm::reftobase::Holder<reco::Candidate, pat::METRef>	         	rb_cand_h_p_m;
  edm::reftobase::Holder<reco::Candidate, pat::ParticleRef>	 	rb_cand_h_p_p;
  edm::reftobase::Holder<reco::Candidate, pat::CompositeCandidateRef>	rb_cand_h_p_cc;
  edm::reftobase::Holder<reco::Candidate, pat::PFParticleRef>	 	rb_cand_h_p_pfp;
  edm::reftobase::Holder<reco::Candidate, pat::GenericParticleRef>	rb_cand_h_p_gp;
  edm::reftobase::Holder<reco::Candidate, pat::ConversionRef>           rb_cand_h_p_c;
    /*   With indirect holder (RefHolder)   */
  edm::reftobase::RefHolder<pat::ElectronRef>	 	rb_rh_p_e;
  edm::reftobase::RefHolder<pat::MuonRef>	 	rb_rh_p_mu;
  edm::reftobase::RefHolder<pat::TauRef>	 	rb_rh_p_t;
  edm::reftobase::RefHolder<pat::PhotonRef>	 	rb_rh_p_ph;
  edm::reftobase::RefHolder<pat::JetRef>	 	rb_rh_p_j;
  edm::reftobase::RefHolder<pat::METRef>	 	rb_rh_p_m;
  edm::reftobase::RefHolder<pat::ParticleRef>	 	rb_rh_p_p;
  edm::reftobase::RefHolder<pat::CompositeCandidateRef>	rb_rh_p_cc;
  edm::reftobase::RefHolder<pat::PFParticleRef>	 	rb_rh_p_pfp;
  edm::reftobase::RefHolder<pat::GenericParticleRef>    rb_rh_p_gp;
  edm::reftobase::RefHolder<pat::ConversionRef>         rb_rh_p_c;
    /*   With direct VectorHolder   */
  /*   RefToBaseVector<Candidate> from PATObjects, not yet provided. Useful?   */
  /*
  edm::reftobase::VectorHolder<reco::Candidate, pat::ElectronRefVector>	        rb_cand_vh_p_e;
  edm::reftobase::VectorHolder<reco::Candidate, pat::MuonRefVector>	        rb_cand_vh_p_mu;
  edm::reftobase::VectorHolder<reco::Candidate, pat::TauRefVector>	        rb_cand_vh_p_t;
  edm::reftobase::VectorHolder<reco::Candidate, pat::PhotonRefVector>	        rb_cand_vh_p_ph;
  edm::reftobase::VectorHolder<reco::Candidate, pat::JetRefVector>	        rb_cand_vh_p_j;
  edm::reftobase::VectorHolder<reco::Candidate, pat::METRefVector>	        rb_cand_vh_p_m;
  edm::reftobase::VectorHolder<reco::Candidate, pat::ParticleRefVector>	        rb_cand_vh_p_p;
  edm::reftobase::VectorHolder<reco::Candidate, pat::PFParticleRefVector>	rb_cand_vh_p_pfp;
  edm::reftobase::VectorHolder<reco::Candidate, pat::GenericParticleRefVector>	rb_cand_vh_p_gp;
  */
  edm::reftobase::VectorHolder<reco::Candidate, pat::CompositeCandidateRefVector>	rb_cand_vh_p_cc;
    /*   With indirect holder (RefVectorHolder)   */
  /*
  edm::reftobase::RefVectorHolder<pat::ElectronRefVector>	 rb_rvh_p_e;
  edm::reftobase::RefVectorHolder<pat::MuonRefVector>	         rb_rvh_p_mu;
  edm::reftobase::RefVectorHolder<pat::TauRefVector>	         rb_rvh_p_t;
  edm::reftobase::RefVectorHolder<pat::PhotonRefVector>	         rb_rvh_p_ph;
  edm::reftobase::RefVectorHolder<pat::JetRefVector>	         rb_rvh_p_j;
  edm::reftobase::RefVectorHolder<pat::METRefVector>	         rb_rvh_p_m;
  edm::reftobase::RefVectorHolder<pat::ParticleRefVector>	 rb_rvh_p_p;
  edm::reftobase::RefVectorHolder<pat::PFParticleRefVector>	 rb_rvh_p_pfp;
  edm::reftobase::RefVectorHolder<pat::GenericParticleRefVector> rb_rvh_p_gp;
  */
  edm::reftobase::RefVectorHolder<pat::CompositeCandidateRefVector> rb_rvh_p_cc;

  /*   RefToBase<AODType> from PATObjects. In addition to the ones for Candidate    */
  /*
  edm::reftobase::Holder<reco::GsfElectron, pat::ElectronRef>	rb_e_h_p_e;
  edm::reftobase::Holder<reco::Muon, pat::MuonRef>	        rb_mu_h_p_mu;
  edm::reftobase::Holder<reco::BaseTau, pat::TauRef>	        rb_t_h_p_t;
  edm::reftobase::Holder<reco::Photon, pat::PhotonRef>		rb_ph_h_p_ph;
  edm::reftobase::Holder<reco::Jet, pat::JetRef>	        rb_j_h_p_j;
  edm::reftobase::Holder<reco::MET, pat::METRef>	        rb_m_h_p_m;

  edm::reftobase::VectorHolder<reco::GsfElectron, pat::ElectronRefVector>   rb_e_vh_p_e;
  edm::reftobase::VectorHolder<reco::Muon, pat::MuonRefVector>		    rb_mu_vh_p_mu;
  edm::reftobase::VectorHolder<reco::BaseTau, pat::TauRefVector> 	    rb_t_vh_p_t;
  edm::reftobase::VectorHolder<reco::Photon, pat::PhotonRefVector>	    rb_ph_vh_p_ph;
  edm::reftobase::VectorHolder<reco::Jet, pat::JetRefVector> 		    rb_j_vh_p_j;
  edm::reftobase::VectorHolder<reco::MET, pat::METRefVector> 		    rb_m_vh_p_m;
  */

  edm::Ptr<pat::Jet> ptr_Jet;
  edm::Ptr<pat::MET> ptr_MET;
  edm::Ptr<pat::Electron> ptr_Electron;
  edm::Ptr<pat::Conversion> ptr_Conversion;
  edm::Ptr<pat::Muon> ptr_Muon;
  edm::Ptr<pat::Tau> ptr_Tau;

  edm::FwdPtr<pat::PackedCandidate> fwdptr_pc;
  edm::Wrapper< edm::FwdPtr<pat::PackedCandidate> > w_fwdptr_pc;
  std::vector< edm::FwdPtr<pat::PackedCandidate> > v_fwdptr_pc;
  edm::Wrapper< std::vector< edm::FwdPtr<pat::PackedCandidate> > > wv_fwdptr_pc;

  edm::Wrapper<edm::Association<pat::PackedCandidateCollection > > w_asso_pc;
  edm::Wrapper<edm::Association<reco::PFCandidateCollection > >    w_asso_pfc;
  edm::Wrapper<edm::Association<std::vector<pat::PackedGenParticle> > > asso_pgp;


  std::vector< edm::Ptr<pat::Jet> > vptr_jet;
  std::vector< std::vector< edm::Ptr<pat::Jet> > > vvptr_jet;
  edm::Wrapper< std::vector< edm::Ptr<pat::Jet> > > wvptr_jet; 
  edm::Wrapper< std::vector< std::vector< edm::Ptr<pat::Jet> > > > wvvptr_jet;


  };

}

#undef  _BACKWARD_BACKWARD_WARNING_H
)DICTPAYLOAD";
    static const char* classesHeaders[]={
"__gnu_cxx::__normal_iterator<const pat::CompositeCandidate*,vector<pat::CompositeCandidate> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Conversion*,vector<pat::Conversion> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Electron*,vector<pat::Electron> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::GenericParticle*,vector<pat::GenericParticle> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Hemisphere*,vector<pat::Hemisphere> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Jet*,vector<pat::Jet> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::MET*,vector<pat::MET> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::MHT*,vector<pat::MHT> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Muon*,vector<pat::Muon> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::PFParticle*,vector<pat::PFParticle> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::PackedCandidate*,vector<pat::PackedCandidate> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::PackedGenParticle*,vector<pat::PackedGenParticle> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Particle*,vector<pat::Particle> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Photon*,vector<pat::Photon> >", payloadCode, "@",
"__gnu_cxx::__normal_iterator<const pat::Tau*,vector<pat::Tau> >", payloadCode, "@",
"edm::Association<pat::PackedCandidateCollection>", payloadCode, "@",
"edm::Association<std::vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::Association<vector<pat::PackedCandidate> >", payloadCode, "@",
"edm::Association<vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::AtomicPtrCache<edm::RefVector<vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<vector<reco::Track>,reco::Track> > >", payloadCode, "@",
"edm::AtomicPtrCache<reco::TrackRefVector>", payloadCode, "@",
"edm::AtomicPtrCache<std::vector<reco::PFCandidatePtr> >", payloadCode, "@",
"edm::AtomicPtrCache<std::vector<reco::SuperCluster> >", payloadCode, "@",
"edm::AtomicPtrCache<vector<edm::Ptr<reco::PFCandidate> > >", payloadCode, "@",
"edm::AtomicPtrCache<vector<reco::SuperCluster> >", payloadCode, "@",
"edm::FwdPtr<pat::PackedCandidate>", payloadCode, "@",
"edm::Ptr<pat::Conversion>", payloadCode, "@",
"edm::Ptr<pat::Electron>", payloadCode, "@",
"edm::Ptr<pat::Jet>", payloadCode, "@",
"edm::Ptr<pat::MET>", payloadCode, "@",
"edm::Ptr<pat::Muon>", payloadCode, "@",
"edm::Ptr<pat::Tau>", payloadCode, "@",
"edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >", payloadCode, "@",
"edm::Ref<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >", payloadCode, "@",
"edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >", payloadCode, "@",
"edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >", payloadCode, "@",
"edm::Ref<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >", payloadCode, "@",
"edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >", payloadCode, "@",
"edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >", payloadCode, "@",
"edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >", payloadCode, "@",
"edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >", payloadCode, "@",
"edm::Ref<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >", payloadCode, "@",
"edm::Ref<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >", payloadCode, "@",
"edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >", payloadCode, "@",
"edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >", payloadCode, "@",
"edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >", payloadCode, "@",
"edm::RefProd<pat::PackedCandidateCollection>", payloadCode, "@",
"edm::RefProd<std::vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::RefProd<vector<pat::PackedCandidate> >", payloadCode, "@",
"edm::RefProd<vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> >", payloadCode, "@",
"edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> >", payloadCode, "@",
"edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> >", payloadCode, "@",
"edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> >", payloadCode, "@",
"edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> >", payloadCode, "@",
"edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> >", payloadCode, "@",
"edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> >", payloadCode, "@",
"edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> >", payloadCode, "@",
"edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> >", payloadCode, "@",
"edm::RefVector<vector<pat::PackedCandidate>,pat::PackedCandidate,edm::refhelper::FindUsingAdvance<vector<pat::PackedCandidate>,pat::PackedCandidate> >", payloadCode, "@",
"edm::RefVector<vector<pat::PackedGenParticle>,pat::PackedGenParticle,edm::refhelper::FindUsingAdvance<vector<pat::PackedGenParticle>,pat::PackedGenParticle> >", payloadCode, "@",
"edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> >", payloadCode, "@",
"edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> >", payloadCode, "@",
"edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> >", payloadCode, "@",
"edm::Wrapper<edm::Association<pat::PackedCandidateCollection> >", payloadCode, "@",
"edm::Wrapper<edm::Association<std::vector<pat::PackedGenParticle> > >", payloadCode, "@",
"edm::Wrapper<edm::Association<vector<pat::PackedCandidate> > >", payloadCode, "@",
"edm::Wrapper<edm::Association<vector<pat::PackedGenParticle> > >", payloadCode, "@",
"edm::Wrapper<edm::FwdPtr<pat::PackedCandidate> >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Conversion>,pat::Conversion,edm::refhelper::FindUsingAdvance<vector<pat::Conversion>,pat::Conversion> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Hemisphere>,pat::Hemisphere,edm::refhelper::FindUsingAdvance<vector<pat::Hemisphere>,pat::Hemisphere> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", payloadCode, "@",
"edm::Wrapper<edm::RefVector<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", payloadCode, "@",
"edm::Wrapper<pat::CompositeCandidateRefVector>", payloadCode, "@",
"edm::Wrapper<pat::ConversionRefVector>", payloadCode, "@",
"edm::Wrapper<pat::ElectronRefVector>", payloadCode, "@",
"edm::Wrapper<pat::GenericParticleRefVector>", payloadCode, "@",
"edm::Wrapper<pat::HemisphereRefVector>", payloadCode, "@",
"edm::Wrapper<pat::JetRefVector>", payloadCode, "@",
"edm::Wrapper<pat::METRefVector>", payloadCode, "@",
"edm::Wrapper<pat::MuonRefVector>", payloadCode, "@",
"edm::Wrapper<pat::PFParticleRefVector>", payloadCode, "@",
"edm::Wrapper<pat::ParticleRefVector>", payloadCode, "@",
"edm::Wrapper<pat::PhotonRefVector>", payloadCode, "@",
"edm::Wrapper<pat::TauRefVector>", payloadCode, "@",
"edm::Wrapper<std::vector<edm::FwdPtr<pat::PackedCandidate> > >", payloadCode, "@",
"edm::Wrapper<std::vector<edm::Ptr<pat::Jet> > >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::CompositeCandidate> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Conversion> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Electron> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::GenericParticle> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Hemisphere> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Jet> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::MET> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::MHT> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Muon> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::PFParticle> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::PackedCandidate> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Particle> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Photon> >", payloadCode, "@",
"edm::Wrapper<std::vector<pat::Tau> >", payloadCode, "@",
"edm::Wrapper<std::vector<std::vector<edm::Ptr<pat::Jet> > > >", payloadCode, "@",
"edm::Wrapper<vector<edm::FwdPtr<pat::PackedCandidate> > >", payloadCode, "@",
"edm::Wrapper<vector<edm::Ptr<pat::Jet> > >", payloadCode, "@",
"edm::Wrapper<vector<pat::CompositeCandidate> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Conversion> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Electron> >", payloadCode, "@",
"edm::Wrapper<vector<pat::GenericParticle> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Hemisphere> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Jet> >", payloadCode, "@",
"edm::Wrapper<vector<pat::MET> >", payloadCode, "@",
"edm::Wrapper<vector<pat::MHT> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Muon> >", payloadCode, "@",
"edm::Wrapper<vector<pat::PFParticle> >", payloadCode, "@",
"edm::Wrapper<vector<pat::PackedCandidate> >", payloadCode, "@",
"edm::Wrapper<vector<pat::PackedGenParticle> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Particle> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Photon> >", payloadCode, "@",
"edm::Wrapper<vector<pat::Tau> >", payloadCode, "@",
"edm::Wrapper<vector<vector<edm::Ptr<pat::Jet> > > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::CompositeCandidateRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::ElectronRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::GenericParticleRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::JetRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::METRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::MuonRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::PFParticleRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::ParticleRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::PhotonRef>", payloadCode, "@",
"edm::reftobase::Holder<reco::Candidate,pat::TauRef>", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<vector<pat::Electron>,pat::Electron> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::GenericParticle>,pat::GenericParticle,edm::refhelper::FindUsingAdvance<vector<pat::GenericParticle>,pat::GenericParticle> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<vector<pat::Jet>,pat::Jet> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<vector<pat::MET>,pat::MET> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<vector<pat::Muon>,pat::Muon> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::PFParticle>,pat::PFParticle,edm::refhelper::FindUsingAdvance<vector<pat::PFParticle>,pat::PFParticle> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Particle>,pat::Particle,edm::refhelper::FindUsingAdvance<vector<pat::Particle>,pat::Particle> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Photon>,pat::Photon,edm::refhelper::FindUsingAdvance<vector<pat::Photon>,pat::Photon> > >", payloadCode, "@",
"edm::reftobase::RefHolder<edm::Ref<vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<vector<pat::Tau>,pat::Tau> > >", payloadCode, "@",
"edm::reftobase::RefHolder<pat::CompositeCandidateRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::ElectronRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::GenericParticleRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::JetRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::METRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::MuonRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::PFParticleRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::ParticleRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::PhotonRef>", payloadCode, "@",
"edm::reftobase::RefHolder<pat::TauRef>", payloadCode, "@",
"edm::reftobase::RefVectorHolder<edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", payloadCode, "@",
"edm::reftobase::RefVectorHolder<pat::CompositeCandidateRefVector>", payloadCode, "@",
"edm::reftobase::VectorHolder<reco::Candidate,edm::RefVector<vector<pat::CompositeCandidate>,pat::CompositeCandidate,edm::refhelper::FindUsingAdvance<vector<pat::CompositeCandidate>,pat::CompositeCandidate> > >", payloadCode, "@",
"edm::reftobase::VectorHolder<reco::Candidate,pat::CompositeCandidateRefVector>", payloadCode, "@",
"pat::CompositeCandidate", payloadCode, "@",
"pat::CompositeCandidateRef", payloadCode, "@",
"pat::CompositeCandidateRefVector", payloadCode, "@",
"pat::Conversion", payloadCode, "@",
"pat::ConversionRef", payloadCode, "@",
"pat::ConversionRefVector", payloadCode, "@",
"pat::Electron", payloadCode, "@",
"pat::ElectronRef", payloadCode, "@",
"pat::ElectronRefVector", payloadCode, "@",
"pat::GenericParticle", payloadCode, "@",
"pat::GenericParticleRef", payloadCode, "@",
"pat::GenericParticleRefVector", payloadCode, "@",
"pat::Hemisphere", payloadCode, "@",
"pat::HemisphereRef", payloadCode, "@",
"pat::HemisphereRefVector", payloadCode, "@",
"pat::Jet", payloadCode, "@",
"pat::JetRef", payloadCode, "@",
"pat::JetRefVector", payloadCode, "@",
"pat::Lepton<reco::BaseTau>", payloadCode, "@",
"pat::Lepton<reco::GsfElectron>", payloadCode, "@",
"pat::Lepton<reco::Muon>", payloadCode, "@",
"pat::MET", payloadCode, "@",
"pat::MET::PackedMETUncertainty", payloadCode, "@",
"pat::MET::Vector2", payloadCode, "@",
"pat::METRef", payloadCode, "@",
"pat::METRefVector", payloadCode, "@",
"pat::MHT", payloadCode, "@",
"pat::Muon", payloadCode, "@",
"pat::MuonRef", payloadCode, "@",
"pat::MuonRefVector", payloadCode, "@",
"pat::PATObject<reco::BaseTau>", payloadCode, "@",
"pat::PATObject<reco::CompositeCandidate>", payloadCode, "@",
"pat::PATObject<reco::GsfElectron>", payloadCode, "@",
"pat::PATObject<reco::Jet>", payloadCode, "@",
"pat::PATObject<reco::LeafCandidate>", payloadCode, "@",
"pat::PATObject<reco::MET>", payloadCode, "@",
"pat::PATObject<reco::Muon>", payloadCode, "@",
"pat::PATObject<reco::PFCandidate>", payloadCode, "@",
"pat::PATObject<reco::Photon>", payloadCode, "@",
"pat::PATObject<reco::RecoCandidate>", payloadCode, "@",
"pat::PFParticle", payloadCode, "@",
"pat::PFParticleRef", payloadCode, "@",
"pat::PFParticleRefVector", payloadCode, "@",
"pat::PackedCandidate", payloadCode, "@",
"pat::PackedCandidateRef", payloadCode, "@",
"pat::PackedCandidateRefVector", payloadCode, "@",
"pat::PackedGenParticle", payloadCode, "@",
"pat::PackedGenParticleRef", payloadCode, "@",
"pat::PackedGenParticleRefVector", payloadCode, "@",
"pat::Particle", payloadCode, "@",
"pat::ParticleRef", payloadCode, "@",
"pat::ParticleRefVector", payloadCode, "@",
"pat::Photon", payloadCode, "@",
"pat::PhotonRef", payloadCode, "@",
"pat::PhotonRefVector", payloadCode, "@",
"pat::Tau", payloadCode, "@",
"pat::TauRef", payloadCode, "@",
"pat::TauRefVector", payloadCode, "@",
"pat::tau::TauCaloSpecific", payloadCode, "@",
"pat::tau::TauPFEssential", payloadCode, "@",
"pat::tau::TauPFSpecific", payloadCode, "@",
"vector<edm::FwdPtr<pat::PackedCandidate> >", payloadCode, "@",
"vector<edm::Ptr<pat::Jet> >", payloadCode, "@",
"vector<pat::CompositeCandidate>", payloadCode, "@",
"vector<pat::CompositeCandidate>::const_iterator", payloadCode, "@",
"vector<pat::Conversion>", payloadCode, "@",
"vector<pat::Conversion>::const_iterator", payloadCode, "@",
"vector<pat::Electron>", payloadCode, "@",
"vector<pat::Electron>::const_iterator", payloadCode, "@",
"vector<pat::GenericParticle>", payloadCode, "@",
"vector<pat::GenericParticle>::const_iterator", payloadCode, "@",
"vector<pat::Hemisphere>", payloadCode, "@",
"vector<pat::Hemisphere>::const_iterator", payloadCode, "@",
"vector<pat::Jet>", payloadCode, "@",
"vector<pat::Jet>::const_iterator", payloadCode, "@",
"vector<pat::MET::PackedMETUncertainty>", payloadCode, "@",
"vector<pat::MET>", payloadCode, "@",
"vector<pat::MET>::const_iterator", payloadCode, "@",
"vector<pat::MHT>", payloadCode, "@",
"vector<pat::MHT>::const_iterator", payloadCode, "@",
"vector<pat::Muon>", payloadCode, "@",
"vector<pat::Muon>::const_iterator", payloadCode, "@",
"vector<pat::PFParticle>", payloadCode, "@",
"vector<pat::PFParticle>::const_iterator", payloadCode, "@",
"vector<pat::PackedCandidate>", payloadCode, "@",
"vector<pat::PackedCandidate>::const_iterator", payloadCode, "@",
"vector<pat::PackedGenParticle>", payloadCode, "@",
"vector<pat::PackedGenParticle>::const_iterator", payloadCode, "@",
"vector<pat::Particle>", payloadCode, "@",
"vector<pat::Particle>::const_iterator", payloadCode, "@",
"vector<pat::Photon>", payloadCode, "@",
"vector<pat::Photon>::const_iterator", payloadCode, "@",
"vector<pat::Tau>", payloadCode, "@",
"vector<pat::Tau>::const_iterator", payloadCode, "@",
"vector<pat::tau::TauCaloSpecific>", payloadCode, "@",
"vector<pat::tau::TauPFEssential>", payloadCode, "@",
"vector<pat::tau::TauPFSpecific>", payloadCode, "@",
"vector<std::vector<edm::Ptr<pat::Jet> > >", payloadCode, "@",
"vector<vector<edm::Ptr<pat::Jet> > >", payloadCode, "@",
nullptr};

    static bool isInitialized = false;
    if (!isInitialized) {
      TROOT::RegisterModule("DataFormatsPatCandidates_x3r",
        headers, includePaths, payloadCode, fwdDeclCode,
        TriggerDictionaryInitialization_DataFormatsPatCandidates_x3r_Impl, {}, classesHeaders);
      isInitialized = true;
    }
  }
  static struct DictInit {
    DictInit() {
      TriggerDictionaryInitialization_DataFormatsPatCandidates_x3r_Impl();
    }
  } __TheDictionaryInitializer;
}
void TriggerDictionaryInitialization_DataFormatsPatCandidates_x3r() {
  TriggerDictionaryInitialization_DataFormatsPatCandidates_x3r_Impl();
}
